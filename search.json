[{"title":"Hello World","url":"/2021/06/07/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.Hello.</p>\n<span id=\"more\"></span>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<h3 id=\"Create-a-new-post\">Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\">Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\">Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\">Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"读书笔记：《活下去的理由》","url":"/2021/06/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E3%80%8A%E6%B4%BB%E4%B8%8B%E5%8E%BB%E7%9A%84%E7%90%86%E7%94%B1%E3%80%8B/","content":"<h1>活下去的理由</h1>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<strong>马特.海格【著】      赵燕飞【译】</strong></p>\n<span id=\"more\"></span>\n<h2 id=\"序-这本书是不可能存在的\">序 这本书是不可能存在的</h2>\n<blockquote>\n<p>文字（口头文字或书面文字）是我们跟世界连接的纽带，谈论它、书写它可以帮助我们连接彼此，连接真实的<br>\n自我。</p>\n</blockquote>\n<blockquote>\n<p>如果我们有了毛病，我们会觉得羞耻。但我们不必永远羞耻，把它讲出来，甚至读出来、写下来，这会让我们获得解脱</p>\n</blockquote>\n<p>注：抑郁症也好，其他的神经质方面的问题，说出来或者写出来都是有好处的。</p>\n<blockquote>\n<p>当你身处深渊底部时，永远都不会有清晰的视野。</p>\n</blockquote>\n<p>注：你觉得你的未来没有希望，其实并不是如此。</p>\n<h2 id=\"1-坠落\">1 坠落</h2>\n<h3 id=\"我死去的那一天\">我死去的那一天</h3>\n<blockquote>\n<p>最初只是一个念头，我感觉有点不对劲，但没有意识到那是什么。一秒钟后，我的头脑里出现一种奇怪的感觉，后脑勺靠近脖子的地方，也就是小脑的部位，出现了某种生理活动。强烈的脉动、颤抖，好像有一只蝴蝶被困在里面，还带有刺痛感。当时我不了解抑郁症和焦虑症会导致这些<strong>奇怪的生理反应</strong>，我只以为我快死了。</p>\n</blockquote>\n<p>注：抑郁症和焦虑证发作时真实的心理和生理感受</p>\n<h3 id=\"为什么抑郁症很难被人理解\">为什么抑郁症很难被人理解</h3>\n<blockquote>\n<p>它并不总是有一个明显的病因</p>\n<p>它能“感染”百万富翁，发丝柔顺的人，婚姻幸福人士，刚被升职的人，会跳踢踏舞、玩扑克牌魔术、弹吉他的人，毛孔紧致的人，状<br>\n态更新里散发着快乐的人——总之外表看起来毫无理由抑郁的人。</p>\n</blockquote>\n<h3 id=\"美景\">美景</h3>\n<h3 id=\"跨越时间的对话（一）\">跨越时间的对话（一）</h3>\n<blockquote>\n<p>生活永远不会是完美的。我仍然会偶尔抑郁，但已经好多了。痛苦再也不会像那时一样严重。我找到了自己。我很快乐。现在，我是快乐的。暴风雨会停止的。相信我。</p>\n</blockquote>\n<h3 id=\"扔掉雨伞，直面风雨\">扔掉雨伞，直面风雨</h3>\n<blockquote>\n<p><strong>怎样更好地应对抑郁症？<strong>没有神奇药丸。治疗慢性痛症让我们明白，其实我们</strong>很难推翻那些身体和头脑的固有反应</strong>，相反，我们必须跟随情绪的线索，<strong>关注低落情绪产生的根源</strong>——过度工作、过少睡眠的生活习惯。我们需要更丰富的描述情绪的语汇，并<strong>有意识地寻找中断低落情绪的工具</strong>，制止它转变为更长期、更严重的情绪低落状态。<strong>这些工具包括改变我们的思维方式，改变我们的周遭事件、情感关系、身体状况（通过锻炼、冥想或饮食）</strong>。  ——乔纳森·罗滕伯格（Jonathan Rottenberg）[进化心理学家]</p>\n</blockquote>\n<p>注：基本上说出了除了吃药以外应对抑郁症的通用方法。</p>\n<h3 id=\"生活\">生活</h3>\n<blockquote>\n<p>我是个失败者，半途而废的人。我一事无成，未来毫无希望。我正滑下深渊，即将不幸变为抑郁症的猎物。但我并未意识到这一点，或者我并不在意。我只想着逃离  。</p>\n</blockquote>\n<p>注：患上抑郁症的影响因素之一。</p>\n<h3 id=\"无限\">无限</h3>\n<blockquote>\n<p>进化心理学家们或许是对的，人类进化得太超前了，作为第一个能够全然觉知宇宙之浩瀚的物种，人类也有了能够**感知如宇宙般浩瀚的黑暗与痛苦的能力，**或许这就是人类智慧的代价</p>\n</blockquote>\n<h3 id=\"我的症状\">我的症状</h3>\n<blockquote>\n<p>感觉镜子里的我似乎是另一个人。<br>\n胳膊、双手、胸部、咽喉和头背部的刺痛感。<br>\n无法考虑未来。（对我来说是没有未来的。）<br>\n害怕变疯，害怕被送到精神病院，穿上约束服，关进软壁病房。<br>\n臆想症。<br>\n分离焦虑。<br>\n旷野恐惧症。<br>\n持续的重度恐惧。<br>\n精神上筋疲力尽。<br>\n身体上筋疲力尽。<br>\n感觉自己一无是处。<br>\n胸口紧，偶尔疼痛。<br>\n即使站着不动，也感觉在坠落。<br>\n四肢疼痛。<br>\n偶尔失语。<br>\n迷茫。<br>\n汗津津的。<br>\n无限的悲伤。<br>\n增长的性幻想。（用性幻想来平衡对死亡的恐惧。）<br>\n想远离人群，希望自己身处另一个时空。<br>\n渴望成为其他人，任何人都可以。<br>\n食欲下降（6 个月内我的体重减了 28 磅）。<br>\n内在的颤抖（我叫它灵魂颤抖）。<br>\n感觉我马上会惊恐发作。<br>\n感觉我呼吸的空气太稀薄。<br>\n失眠。<br>\n不断搜索“我要死了”或“我要疯了”的警告信号。<br>\n找到如上警告信号，并深信不疑。<br>\n有快步走路的欲望。<br>\n奇怪的似曾相识感，还会觉得某件事像是回忆但还未发生，至少对我还未发生。<br>\n在我的视野边缘看见黑暗。<br>\n想要关闭噩梦般的图像，有时我合上眼就能看到。<br>\n渴望跳脱出自己。一周，一天，一小时，上帝啊，一秒钟也行 。</p>\n</blockquote>\n<blockquote>\n<p>如果你只是单纯的抑郁症，你会感觉大脑像陷入沼泽，失去动力，迟缓不动。但如果加入了焦虑症，你身陷的沼泽中还会出现漩涡。泥水中的怪物像变异的鳄鱼一样以最快速度不停游动。你一刻都不能放松，每一秒都处在崩溃的边缘，你绝望地试图浮出水面、呼吸空气——那些对你来说如此奢侈，对岸上的人来说却唾手可得的空气。</p>\n</blockquote>\n<p>注：这个作者总喜欢用比喻的方式来描述感受。</p>\n<h3 id=\"糟糕日子银行\">糟糕日子银行*</h3>\n<blockquote>\n<p>那些极其糟糕的日子，虽然很恐怖、很难熬过去，但日后却可以派上用场。你把它们存起来，建立一个糟糕日子银行。那个你不得不从超市逃跑的日子，那个你抑郁到动不了舌头的日子，那个你让父母流泪的日子，那个你差点跳崖自尽的日子。等到你遇到下一个糟糕的日子，你就可以说，好吧，今天是够糟糕的，但之前还有过比这更糟的日子啊。即使今天就是你经历过最糟的日子，至少你知道银行还在那里，你至少存了一笔 。</p>\n</blockquote>\n<p>注：好像我的情况很少能用糟糕日子银行来记录，不过应该也有吧。</p>\n<h3 id=\"事实\">事实</h3>\n<blockquote>\n<p><strong>女性比男性更愿意寻求并接受心理健康问题的治疗。</strong><br>\n如果父母一方被诊断出抑郁症，子女患抑郁症的概率约为 40%。</p>\n</blockquote>\n<h3 id=\"男孩不哭\">男孩不哭</h3>\n<blockquote>\n<p>男性自杀人数远高于女性。在英国，前者是后者的 3 倍，希腊是6 倍，美国是 4 倍。这是世界各国的普遍状况。世界卫生组织的调查<br>\n数据显示，女性自杀人数大于男性的国家和地区仅有中国大陆和中国香港。</p>\n</blockquote>\n<blockquote>\n<p>男性通常把心理疾病看作一种弱点，不愿寻求帮助。</p>\n</blockquote>\n<blockquote>\n<p>反复告诉自己，抑郁症不是某个你“不敢承认”的东西，不需要你自惭形秽，它是一种人类经验，是男孩、女孩、男人、女人、年轻人、老人、黑人、白人、同性恋、异性恋、富人、穷人共有的体验。抑郁症不等于你，它仅仅是某个发生在你身上的东西，某个可以被交谈所缓解的东西。文字，安慰，支持。我花了十年，才敢也才能公开、得体地对读者谈论我的经历。我很快发现交谈本身就是一种治疗。交谈所在之处，就有希望  。</p>\n</blockquote>\n<h2 id=\"2-着陆\">2 着陆</h2>\n<blockquote>\n<p>“……暴风雨结束后，你不会记得自己是怎样活下来的。你甚至不确定暴风雨真的结束了。但有一件事是确定的：当你穿过了暴风雨，你就不再是原来那个人。这就是关于暴风雨的一切。“               ——村上春树，《海边的卡夫卡》</p>\n</blockquote>\n<h3 id=\"未知的未知\">未知的未知</h3>\n<blockquote>\n<p>“只有傻瓜和骗子会告诉你大脑是如何工作的。”   ——大卫·亚当  ，《停不下来的人》（强迫症精彩著作）</p>\n</blockquote>\n<blockquote>\n<p>有一件事是确定无疑的：我们距离科学的终点还很遥远，<strong>尤其是神经科学这样的“婴儿期”学科</strong>。我们今天知道的大多数知识，在未来<br>\n都将被推翻或重新评估。<strong>这就是科学，不依赖盲目信仰，只坚持不断怀疑</strong>  。</p>\n</blockquote>\n<blockquote>\n<p>现在我只坚持对我有用的疗法：锻炼身体，瑜伽，全神贯注于我热爱的某件事或某个人。没有哪种疗法适合所有人，你自己就是最好的实验室。</p>\n</blockquote>\n<p>注：哪种疗法对你有用，你就可以采用</p>\n<h3 id=\"魔鬼\">魔鬼</h3>\n<blockquote>\n<p>“怪物是真实的，”斯蒂芬·金说，“鬼也是真实的。它们住在我们心里，而且有时会战胜我们。”</p>\n</blockquote>\n<h3 id=\"存在\">存在</h3>\n<blockquote>\n<p>死亡、腐烂等一切阴暗的事物会孕育美好，这或许有点难以接受，但我相信。正如永远伟大的诗人、偶尔焦虑的旷野恐惧症患者艾米莉·狄金森（Emily Dickinson）所说：“那永远不会再来的事物，才使生活如此甜美。”</p>\n</blockquote>\n<p>注：永远不会再来的事物，衰老，生病，死亡。</p>\n<h2 id=\"3-上升\">3 上升</h2>\n<h3 id=\"一个人走路的艺术\">一个人走路的艺术</h3>\n<blockquote>\n<p>那是 1999 年。很多人还没有手机。那时“一个人”还是真正意义上的一个人。于是我会迅速穿上外套，抓点零钱，以尽可能快的速度走出家门，试图超过恐慌的速度。<br>\n当我走到威灵顿路尽头，黑暗开始对我低语。我转弯走上斯利福德路，看到橙色砖头的排屋飘着窗纱。深深的不安全感弥漫而来，我感觉自己仿佛身处一艘飞离地球轨道的飞船之上——我不是在去商店的路上，我是在阿波罗 13 号上。<br>\n“没事的，”我小声对自己说。<br>\n我路过一些遛狗的人，有的无视我，有的皱眉，有的竟然对我微笑。我也不得不微笑，然后我的头脑会立刻惩罚我。这就是抑郁症和焦虑症的奇怪之处。它们极度害怕快乐，即使你本人很向往快乐。如果它们逮到你笑，甚至假装笑，你就糟糕了。笑是绝对不被允许的，它们会用 10 吨的抗衡力来抵消它。<br>\n怪诞。那种一个人在外面的感觉极不自然，就像没有了墙的房顶一样。我看见商店在前方。“兰帝斯”① 的招牌看起来那么小，那么远。巨大的悲伤和恐惧让我难以迈步。<br>\n打死我也做不到。</p>\n<p>打死我也走不到商店。一个人。找到牛奶和酵母酱。<br>\n如果你现在回家，你会变得更弱。你要怎么办？回家迷失自我、变成疯子吗？如果你现在回家，一辈子住在软壁病房的概率<br>\n会增加。走路，走到商店。它就是个商店。从 10 岁起，你就可以一个人走到这个商店了。一步一步走，挺胸抬头。呼吸。<br>\n我的心跳加速了。<br>\n别管它。<br>\n可是你听——砰砰砰砰砰。<br>\n别管它。<br>\n可是你听，你听，真该死，听啊。<br>\n还有别的。<br>\n脑海里的图像，堪比恐怖片。头后部的针刺感，蔓延到整个头部。发麻的手和胳膊。被掏空的感觉，解体的感觉，孤魂野鬼<br>\n的感觉。呼吸困难。空气变得稀薄。控制呼吸节奏需要很大的专注度。<br>\n只管去商店，继续走，只管走到商店。<br>\n我进了商店。<br>\n无论有没有安德莉亚陪着，商店都是最令我恐慌的地方。它令我极度焦虑。我不清楚为什么。<br>\n是因为灯光吗？<br>\n是因为横平竖直的过道吗？<br>\n是因为闭路电视摄像机吗？<br>\n是因为那些商标为了引人注目而发出的尖叫吗？当你深深地融入周遭环境时，也许就会听见那些尖叫，阵亡在联合利华手里<br>\n。这里只不过是兰帝斯，不是什么大型超市。门是开着的，街道就在外面。这条街连接着我父母家的街，街上有我父母的房<br>\n子，房子里有安德莉亚，她是一切。如果我跑步，大概一分多钟就能跑回家。<br>\n我努力集中注意力。可可麦片。很难。香甜粟米片。真的很难。脆坚果麦片。蜂蜜怪兽牌蜜糖麦片泡芙。蜂蜜怪兽长得一点<br>\n不像怪兽。我来这里做什么？就是为了证明自己能行吗？太疯狂了。这是我做过最疯狂的事情。</p>\n<p>它只是个商店。<br>\n以前你一个人来过这个商店 500 次。镇定。控制你的情绪。怎么控制？说得好听。每件事都很糟糕，生活就是无尽的<br>\n艰难，每一秒都包含 1000 个挑战。我是 1000 个不同的人，飞速逃离身体中心。<br>\n患病前我没有意识到这种病还会有生理上的症状。我的意思是，没想到发生在脑袋里面的事竟也在感官上有所反应。我的脑<br>\n部有刺痛感，嗡嗡作响，阵跳，这些感觉大多发生在头骨后部的枕叶。我的额叶感觉晕晕乎乎，像电视没信号时的白噪音。<br>\n想得太多了，可能就会感觉到胡思乱想的形状。<br>\n“一分钟里容得下无限的感情，”福楼拜写道，“正如一个小地方容得下一大堆人一样。”<br>\n赶紧离开这个商店。你承受不了了。你的脑袋要爆炸了。<br>\n脑袋是不会爆炸的。生活不是大卫·柯南伯格② 的电影。<br>\n也许我会继续下坠？也许发生在伊比萨的坠落只是一半？也许地狱还在更下面，我的目的地是那里？也许我会成为诗里患炮弹休克症的士兵，流着口水，号哭着，迷失了自己，连自杀也做不到？也许这个商店将把我推向那个境地？<br>\n收银台后面是一个女孩。我还能想起她的模样。她和我差不多大，也许是我的校友，但我不认识她。她的头发染了红色，显得有点漫不经心。身材丰腴，皮肤白皙，正在读一本明星杂志。她看起来不能再平静了。我真想跟她调换一下，我想成为她，太想了。我这么想很傻吧？是很傻。这整件事听起来都傻透了。<br>\n印第安纳·琼斯和酵母酱的神殿。<br>\n我找到了酵母酱，将它一把抓起，一首 Eric B&amp;Rakim 的说唱音乐在我脑海中高速播放，“我也是个雕塑，按照结构出生……”我是一个没有结构的雕塑。现在，这个无结构的雕塑还需要找到牛奶。冰箱里一列列牛奶瓶很吓人，很不自然。我父母喝低脂牛奶，但低脂牛奶只有一品脱的，没有他们常喝的两品脱的。所以我拿了两瓶一品脱的，食指勾着提手，拿着两瓶牛奶和酵母酱走向收银台。<br>\n砰砰砰砰砰。<br>\n我想成为的女孩，工作并不利索。我猜她是有史以来动作最慢的收银员，许多商店安装自助结账设备大概就是因为有动作这么慢的收银员吧。虽然我想成为她，但是我痛恨她的缓慢。快点好吗？我没说出口。你会不会结账啊？我想重新活一遍，用她的节奏生活。这样我就不会焦虑、抑郁了。我需要慢一点的节奏。</p>\n<p>“你需要袋子吗？”<br>\n我似乎需要个袋子，但我怕她会更慢。一动不动站立着很难。当你全身上下都在恐慌时，走路比站立要好些。<br>\n某些意象漫过我的脑海。我闭上眼，看见侏儒魔鬼开心地嘲笑我，似乎我的疯狂是狂欢节上的表演。<br>\n“不，不需要，我就住在街角。”<br>\n拐弯处。<br>\n我给了她 5 英镑，“不用找钱了。”<br>\n她开始意识到我有点奇怪。我走出商店，重新回到广阔、宽敞的世界。我用最快的速度行走着（我没有跑，这时候跑起来会<br>\n有一种仓皇而逃的感觉）。我是甲板上的一只鱼，需要水。<br>\n“没事了，没事了，没事了……”<br>\n我转过街角，祈祷不要在威灵顿路撞见我认识的人。那里空无一人，只有郊区半独立式的维多利亚后期房屋，一栋栋对望着彼此。终于走到 33 号，我父母的房子。我按门铃，安德莉亚为我开门。我进了屋，可是没有感到如释重负，我的头脑迅速向我指出，因为挺过一趟街角商店之行而感到如释重负，只能证明我有病。<br>\n也许有一天，我的头脑会像商店女孩一样慢，慢到不会向我指出这类事情。<br>\n“你会好的。”安德莉亚说。<br>\n“会的。”我说，努力相信着。<br>\n“我们会帮助你恢复的。”<br>\n陪伴在抑郁症病人的身旁是件不容易的事。</p>\n</blockquote>\n<p>注：这是一段患抑郁症的人到商店买东西的真实记录。有点吓人。</p>\n<h3 id=\"活下去的理由\">活下去的理由</h3>\n<blockquote>\n<p>你以为来到了外星球，没人能理解你经受的痛苦。但实际上，他们理解。你觉得他们不理解，是因为你唯一的参照点是自己。你从<br>\n未经受过这种痛苦，滑入深渊的冲击令你胆战心惊。<br>\n然而，还有其他人来过这里。在那片黑暗之中，有上千万人与你同行。</p>\n</blockquote>\n<blockquote>\n<p>你恨自己。这是因为你敏感。估计每个人都会找到恨自己的理由，如果他们想得跟你一样多的话。其实我们每个人全都是混蛋，也<br>\n都是美妙的天使。</p>\n</blockquote>\n<blockquote>\n<p>头脑有它自己的天气系统。虽然你现在身处龙卷风之中，但龙卷风的能量最终会被耗尽的。坚持住。</p>\n</blockquote>\n<blockquote>\n<p>无视偏见。每一种疾病都曾招来偏见。<strong>我们害怕得病，于是恐惧滋生偏见</strong>。比如，脊髓灰质炎曾被错误地指为穷人才会患的疾病。而抑郁症常被人认为是一种“软弱”或性格缺陷。</p>\n</blockquote>\n<blockquote>\n<p>没有什么会一成不变。现在这种痛苦不会永远持续。如果痛苦告诉你它会持续，是它在撒谎。其实痛苦是一笔债，可以用时间偿清。</p>\n</blockquote>\n<h3 id=\"爱\">爱</h3>\n<blockquote>\n<p>有趣的是，我们根本不是同一类人。安德莉亚喜欢睡懒觉，晚上睡得也早。我睡眠不好，是夜猫子。她职业道德很强，我不强（尽管<br>\n抑郁症神奇地让我拥有了职业道德）。她井井有条，我是她见过最没条理的人。我们的结合，就像氯气和氨气的混合，显然不是个好主意。</p>\n<p>**但她说，我会让她笑，我很“有趣”。**我们喜欢交谈。我们两人都比较害羞、内向，但各有各的方式。安德莉亚是个社交变色龙。她这                                                                  样做是出于善意。她受不了别人感到尴尬，所以总是尽可能委屈自己，迁就对方。我想，如果我给了她什么的话，是让她做自己的机会吧。<br>\n如果确实像叔本华说的，“<strong>为了和其他人一样,我们失掉了四分之三的自己。</strong>”爱就是重新找回那四分之三自己的方式。找回童年就已失<br>\n去的那份自由。<strong>也许，爱就是找到那个可以在他身边做古怪自己的人</strong>。</p>\n</blockquote>\n<blockquote>\n<p>请不要认为这是一段完美的关系。它过去不是，现在也不是。尤其是我们在伊比萨的时光，现在想来似乎是一场漫长的争吵。</p>\n</blockquote>\n<blockquote>\n<p>但争吵只是表面。大浪之下的海水是静止的。我们也是如此。从某种意义上说，<strong>我们争吵，是因为我们知道争吵对感情不会有什么根</strong><br>\n<strong>本的影响</strong>。<strong>当你在某个人面前可以做真实的自己时，你会向外投射不满意的自我</strong>。在伊比萨，我就是这样，我不快乐。当我不快乐时，我\\会试图将自己沉浸在快感里  。</p>\n</blockquote>\n<p>注：这就是一种爱情的模式。</p>\n<blockquote>\n<p>她陪我看医生，鼓励我打心理热线，和我搬进新公寓，鼓励我读书和写作。她赚钱养家，给我时间和空间，替我打理好一切生活琐事。</p>\n</blockquote>\n<p>注：感动</p>\n<h3 id=\"如何陪伴患抑郁症或焦虑症的人\">如何陪伴患抑郁症或焦虑症的人</h3>\n<blockquote>\n<ol>\n<li>要知道你是被需要、被感激的，即使表面上看起来不是这样。</li>\n<li>聆听。</li>\n<li><strong>永远不要说“振作起来”或“高兴起来”，除非你会提供具体、万无一失的操作方法。</strong>（“严厉的爱”不管用，<strong>老套的、温柔的爱就足够了</strong>。）</li>\n<li>抑郁症是一种疾病，如果病人说了一些无心的话，要体谅他们。</li>\n<li>教育自己。要了解最重要的一点：<strong>对你来说很容易的事，比如逛商店，对抑郁症患者也许是不可能完成的挑战。</strong></li>\n<li>别认为这是你的错。别把抑郁症当成流感、慢性疲劳综合征、关节炎。病人得病不是你的错。</li>\n<li>耐心点。这个过程不会很轻松。抑郁症有涨落、起伏，不会保持一个状态。不要把某一个快乐或糟糕的时刻当作痊愈或复发的证<br>\n据。打一场持久战吧。</li>\n<li>接纳现在的他。问问他你能做什么。<strong>其实你能做的主要就是陪在他身边</strong>。</li>\n<li>如果可能的话，解除病人的一切工作、生活压力。</li>\n<li>尽可能别对病人的举动大惊小怪，这会更让他们觉得自己是个怪人。躺在沙发上三天不起？不拉开窗帘？因为决定不了穿哪双袜子哭个没完？那又如何，没什么大不了的。<strong>“正常”其实是主观的，没有什么标准答案。这个地球上有 70 亿人，就有 70 亿种正常。</strong></li>\n</ol>\n</blockquote>\n<h3 id=\"一个微不足道的时刻\">一个微不足道的时刻  *</h3>\n<blockquote>\n<p>那一刻，我脑袋空空的，漫不经心。有 10 秒钟，我醒着，但没有想着抑郁症或焦虑症。我想着工作，想着怎么才能在报纸上发表一篇文章。这不是一个快乐的想法，只是一个中性的想法。但它是穿透乌云的一束光，昭示着太阳还在某处存在着。虽然这 10 秒钟一会儿就过去了，但我有了希望。终有一日，这无痛苦的几秒会变成几分钟、几小时甚至几天。</p>\n</blockquote>\n<h3 id=\"相对于抑郁，这些事更让我自怜\">相对于抑郁，这些事更让我自怜</h3>\n<blockquote>\n<p>耳鸣。<br>\n在烤箱上烫伤了手，不得不戴了一星期怪异的药膏手套。<br>\n不小心把腿点着了。<br>\n丢了工作。<br>\n脚趾断了。<br>\n负债。<br>\n洪水淹了我们的新房，经济损失一万镑。<br>\n我的书在亚马逊上的差评。<br>\n感染诺洛病毒。<br>\n11 岁做了包皮环切术。<br>\n腰背疼痛。<br>\n曾经被黑板砸在身上。<br>\n肠易激综合征。<br>\n距离恐怖袭击仅有一条街的距离。<br>\n湿疹。<br>\n一月份住在赫尔。<br>\n分手。<br>\n在圆白菜包装车间工作。<br>\n从事媒体销售（好吧，是险些从事）。<br>\n吃了有毒的对虾。<br>\n持续三天的偏头痛。</p>\n</blockquote>\n<h3 id=\"向外星人解释地球生活\">向外星人解释地球生活</h3>\n<blockquote>\n<p>我并不认同“任何杀不死你的，都会使你更强大”⑤ 这句话。事实上根本不是这样，那些“杀不死你的”通常会使你更弱小，让你在余生<br>\n里四肢无力，不敢走出家门，甚至是卧室。它们让你颤抖，语无伦\\次，头倚着窗，祈求回到它们出现之前的日子。</p>\n</blockquote>\n<h3 id=\"留白\">留白</h3>\n<blockquote>\n<p>书也是一切。我以一种从未有过的强度，不停地读着，读着，读着。我一直自认为是个爱书之人，但爱书和需要书是不一样的。<strong>那时</strong><br>\n**我需要书，对我来说它们不是奢侈品，而是 A 类毒品。**但我很开心中了书毒，在那 6 个月里，我读的书比大学 5 年读的还多，在魔术般的书籍世界里越陷越深。</p>\n</blockquote>\n<p>注：原来有这样一种喜欢读书的人。知乎上的程浩好像也有这么一段疯狂读书的时期。</p>\n<blockquote>\n<p>人们说，阅读不是为了逃避，就是为了找到自我。我倒是觉得这两者之间其实没有区别，因为我们会在逃避的过程中找到自我。</p>\n</blockquote>\n<blockquote>\n<p>每一本书都是人类头脑在某一特定状态下的产物。所有书籍摆在一起，就是人性的总和。每次阅读一本好书的时候，我都感觉像在看一张藏宝图，而那宝藏就是我自己。但每一张地图都是不完整的，我只有读完全部的书，才能找到宝藏，因而这个找到最好自我的过程是一场无尽的远征。而书籍本身似乎也在隐隐印证着这个观点，因为<strong>每一本书的情节都可以被归结为“某个人对某样东西的追寻”</strong>。</p>\n</blockquote>\n<h3 id=\"巴黎\">巴黎</h3>\n<blockquote>\n<p>如果我拒绝，我就成了一个因为恐惧而不能出国的人。这是疯子才有的行为。而我最大的恐惧，大过死亡的恐惧，就是变成一个疯<br>\n子，把自己完全交付给魔鬼。<strong>于是，一个巨大的恐惧被一个更大的恐惧击败了</strong>。</p>\n</blockquote>\n<blockquote>\n<p>打败一个怪物的最好方法是找到一个更可怕的怪物。</p>\n</blockquote>\n<p>注：有意思的对抗恐惧的经历</p>\n<blockquote>\n<p>那一晚我闭上眼，几小时都睡不着，因为我感觉巴黎一直在移动，好像我还在出租车里。但我很平静，接下来的 4 天里，我也没有<br>\n惊恐发作，只是当我走在巴黎左岸，走在瑞弗里大道，走在蓬皮杜艺术中心顶楼的餐厅里时，会感到一种普遍意义上的焦虑。</p>\n</blockquote>\n<blockquote>\n<p>我开始意识到，<strong>做一些让我惧怕的事（又没有被吓死）就是最好的治疗</strong>。如果你害怕出门，就走出门。如果你害怕封闭空间，就在电梯里待一会儿。如果你有分离焦虑，就强迫自己独自待一会儿。当你抑郁、焦虑时，你的舒适区会从整个世界缩小到一张床，甚至缩小到什么也没有</p>\n</blockquote>\n<blockquote>\n<p>新的地方带给你的刺激与兴奋，会让你既害怕又自由。在熟悉的地方，你的头脑全神贯注于自身，你的卧室没什么值得留意的。外部<br>\n威胁为零，只剩下内部威胁。在异国他乡，环境是新鲜的，你不得不更加关注头脑以外的世界 。</p>\n</blockquote>\n<p>注：新的环境或者去旅游是有好处的。整个这一小节介绍不少对抗焦虑症和抑郁症的方法。</p>\n<blockquote>\n<p>“移动”是“固着”的解药。有时候，动起来真的有用。只是有时候。</p>\n</blockquote>\n<blockquote>\n<p>古斯塔夫·福楼拜说：“旅行使人变得谦虚。因为它使你领悟，人在世界上所占的地位是多么的渺小。”这种视角会带给你自由感。如果<br>\n疾病一方面让你弱化自我价值，一方面却又让你过分在意那些本来无关紧要的细枝末节，你就尤其需要用这种视角看问题。</p>\n</blockquote>\n<p>注：这种视角是指人是很渺小的，这种视角有利于弱化高强度的自我意识</p>\n<blockquote>\n<p>看完电影，安德莉亚对我说，马特·海格身上有太多马特·海格。她是在开玩笑，但也不无道理。任何能<strong>弱化高强度自我意识</strong>的东西，<br>\n我都欢迎。</p>\n</blockquote>\n<p>注：电影是《飞行家》，原句是：霍华德·休斯身上有太多霍华德·休斯。</p>\n<h3 id=\"坚强的理由\">坚强的理由</h3>\n<p>这一小节讲的是作者女朋友妈妈突然查出癌症，然后他与女朋友必须分开一会，最终他克服分离焦虑的事情。</p>\n<blockquote>\n<p>伤口是光进入你内心的地方 。</p>\n</blockquote>\n<blockquote>\n<p>忘掉安全，在你害怕的地方生活。</p>\n</blockquote>\n<blockquote>\n<p>我强迫自己强大起来，将自己置于不舒服的情境中。有时候我们有必要给自己制造一些不适感。</p>\n</blockquote>\n<h3 id=\"武器\">武器</h3>\n<blockquote>\n<p>**我的低自尊被人为地治愈了。**我会躺在床上，微笑着进入梦乡，想着，哇，我真了不起，我要出书了 。</p>\n</blockquote>\n<p>注：人需要通过工作给他带来自信。</p>\n<blockquote>\n<p>但这一次，我有了武器。其中最重要的武器是一种新的认识：我病过，但后来康复了，恢复健康是可能的。还有一个武器是跑步，我知道了<strong>身体会影响头脑</strong>，所以我开始经常跑步。</p>\n</blockquote>\n<p>注：这一次作者3周的时间，感觉都还可以。</p>\n<h3 id=\"跑步\">跑步</h3>\n<blockquote>\n<p>跑步是抑郁症和焦虑症公认的缓解剂，对我也确实很有帮助。</p>\n</blockquote>\n<blockquote>\n<p>跑步也给了我一个聚焦点。我并不是身体多么矫健的人，跑步对我来说是件挺费劲、挺痛苦的事情。但那份用力和不适感是一个很棒<br>\n的聚焦点。我对自己说，训练身体也是训练头脑，类似一种冥想运动。</p>\n</blockquote>\n<blockquote>\n<p>村上春树还说：“在自己的极限内拼尽全力，这就是跑步的本质。”我也信奉这一点，我想这也是跑步有益头脑的原因之一。</p>\n</blockquote>\n<blockquote>\n<p>但这些年来我收集了很多抵抗抑郁的方法，它们偶尔能给我提供帮助，这已经很好了。为战斗准备的武器平时不露锋芒，但<br>\n一遇到战事就能随时点燃战斗力。<strong>写作、阅读、交谈、旅行、瑜伽、冥想、跑步，这些我为了与抑郁症作战准备的武器也是一样。</strong></p>\n</blockquote>\n<p>注：抑郁症专家就是你了。这些好方法我也可以参照一下。</p>\n<h3 id=\"名人\">名人</h3>\n<blockquote>\n<p>抑郁症最恼人的特质是让你无可避免地思考人生。抑郁症让我们都成为思想家 。</p>\n</blockquote>\n<p>这一小节列了一长串患过抑郁症的名人的名字。</p>\n<blockquote>\n<p>重点不在于学到了什么，而在于当我们知道金·凯瑞吃过百忧解，莉娅公主 得过躁郁症时，我们会得到些许安慰，因为抑郁症真的可能发生在任何人身上。</p>\n</blockquote>\n<h3 id=\"亚伯拉罕·林肯和可怕的礼物\">亚伯拉罕·林肯和可怕的礼物</h3>\n<blockquote>\n<p>亚伯拉罕·林肯 32 岁时宣布：“现在我是最痛苦的人。”那时他经历了两次抑郁症发作，精神崩溃。</p>\n</blockquote>\n<blockquote>\n<p>“如果把我的感觉平均分配给全人类，地球上将不再有一张欢喜的脸。我不知道我能否好转，我不允许我不好转。继续现状是不可能的。要么死亡，要么好转。”  ——亚伯拉罕·林肯</p>\n</blockquote>\n<blockquote>\n<p>林肯坚决地直面他的恐惧。从二十多岁到三十多岁，他对自身恐惧的理解越来越深入，思考着阿尔贝·加缪所说的“人类面对的唯一重要问题”。他质问自己是否能活着，是否能面对生命之悲惨。最终他决定，他必须……他有一种“不可抑制的渴望”——要在活着的时候做出一番成就。</p>\n</blockquote>\n<blockquote>\n<p>他征战过心灵的战场，也征战过人间的战场。也许正是对痛苦的切肤感受，赋予了他一颗怜悯之心，驱使着他去改革奴隶制度。</p>\n</blockquote>\n<blockquote>\n<p>弗洛伊德（Freud）的许多著作以他对自身抑郁症的分析和治疗为基础。</p>\n</blockquote>\n<blockquote>\n<p>亚伯拉罕·林肯终生患有抑郁症，从未摆脱，他与抑郁症并肩生活，取得了伟大成就。“林肯的伟大成就不是一种对个人痛苦的征<br>\n服，”约书亚·伍尔夫·申克写道，“他的痛苦和成就来源于同一个东西……不是因为他征服了抑郁症，所以才取得了伟大成就，他的抑郁<br>\n症就是他伟大成就的动力 。</p>\n</blockquote>\n<blockquote>\n<p>把它用在日常生活中就很好了。比如，我发现冷静地认知死亡可以让我更坚定地享受生命，珍惜和孩子、爱人在一起的宝贵时光。抑<br>\n郁症增加了痛苦的强度，却也能增加幸福的强度。</p>\n</blockquote>\n<p>注：抑郁症通常会在夺走一些东西的同时，也留下一些馈赠。  如何与抑郁症共存。</p>\n<h3 id=\"跨越时间的对话（三）\">跨越时间的对话（三）</h3>\n<blockquote>\n<p>你的情绪会一直这么强烈。抑郁症也总是会潜伏在那里，谋划着下一次袭击。但是前面还有这么丰富多彩的生活等着你去体验。抑郁症让你知道，一天的时间可以变得如此漫长而强烈。</p>\n</blockquote>\n<blockquote>\n<p>挺好啊，别担心时间的流逝。一天之中蕴含无限。</p>\n</blockquote>\n<h2 id=\"4-活着\">4 活着</h2>\n<blockquote>\n<p>“心会破碎，但却破碎地活着。”——拜伦，《恰尔德·哈洛尔德游记》</p>\n</blockquote>\n<h3 id=\"世界\">世界</h3>\n<blockquote>\n<p>这个世界在蓄意催人抑郁，因为快乐对经济不利。如果现有的一切就让我们很快乐，我们何必追求更多？</p>\n</blockquote>\n<blockquote>\n<p>生活的意义在于爱你的人。没有谁会为了一部苹果手机活着，手机另一端连接的人才重要。</p>\n</blockquote>\n<h3 id=\"蘑菇云\">蘑菇云</h3>\n<p>本小节介绍了作者大学期间一次勉强算有原因的惊恐发作过程。简单说，就是在十几个人面前做一个ppt报告。</p>\n<h3 id=\"大”焦虑“\">大”焦虑“</h3>\n<blockquote>\n<p>与抑郁症相比，焦虑症更容易因受外界影响而恶化，比如周遭的事物和 21 世纪的生活方式 。</p>\n</blockquote>\n<h3 id=\"慢下来\">慢下来</h3>\n<blockquote>\n<p>没有其他辅助治疗，仅凭药物治好一个人的状况是很少见的。</p>\n</blockquote>\n<blockquote>\n<p>瑜伽  。与其他疗法不同，它把头脑和身体当作一个整体来治疗。</p>\n<p>减慢呼吸 。不需要深呼吸。轻柔地呼吸。吸气 5 秒钟，呼气 5秒钟。坚持下来比较难，但放松的呼吸能有效避免惊恐发作。太多的焦虑症症状——头晕、针刺感、麻刺感——都与呼吸急促直接相关。</p>\n<p>冥想 。不需要吟诵经文。坐下来，花 5 分钟时间，试着想象一个让你平静的事物，一艘停泊在闪闪发光的海面的船，爱人的面庞。<br>\n或者只是专注于你的呼吸。</p>\n<p>接纳 。不要抗争，只是感觉。紧张源于对立，放松源于放手。</p>\n<p>活在当下 。  “如果你想征服生命中的焦虑，活在当下，活在每一个呼吸里。“</p>\n<p>爱 。  焦虑是一种疾病，把我们束缚在自己的噩梦里。爱是向外的作用力，是我们挣脱恐惧的通道。爱人与被爱对他们会有极大的帮助。这种爱不一定要是浪漫的爱情，甚至无须是家人之爱，只要学着用爱的目光看这个世界就够了。爱是一种生命态度，爱可以拯救彼此。</p>\n</blockquote>\n<h3 id=\"高峰和低谷\">高峰和低谷</h3>\n<blockquote>\n<p>我懂得向下不是唯一的方向。如果你坚守在那里，忍耐住，情况会变好的。会变好，然后又变糟，然后又变好。</p>\n<p>正如我住在父母家里时，一个顺势疗法医生告诉我的，“<strong>高峰，低谷，高峰，低谷。</strong>”（她的这句话比她的药酒更管用。）</p>\n</blockquote>\n<h3 id=\"插入语\">插入语</h3>\n<blockquote>\n<p>我获得的人生一课：我们从来没办法只靠自己走出困境。</p>\n</blockquote>\n<h3 id=\"派队\">派队</h3>\n<blockquote>\n<p>“当我与很多人共处一室时，”他写道，“如果让我猜测我的头脑发生了什么变化，我会说，我已经不是我自己了，房间里每个人的特<br>\n质都向我扑过来，我很快就被全面击溃了。”</p>\n</blockquote>\n<p>作者在本小节讲了自己参加派对的经历。虽然这次派对他还是落荒而逃了，但是他并没有惊恐发作。在不知不觉中，他已经进步了。</p>\n<h3 id=\"活下去的理由-2\">#活下去的理由#</h3>\n<p>作者在本节记录了很多有过抑郁症、焦虑、自杀想法的人活下去的理由。</p>\n<h3 id=\"使我感觉更糟的事物\">使我感觉更糟的事物</h3>\n<h3 id=\"使我感觉更好的事物（有时候-）\">使我感觉更好的事物（有时候 ）</h3>\n<h2 id=\"5-存在\">5 存在</h2>\n<h3 id=\"薄脸皮礼赞\">薄脸皮礼赞</h3>\n<blockquote>\n<p>我脸皮薄。我想这是我患抑郁症和焦虑症的主要原因。 或者更准确地讲，这是我有抑郁症和焦虑症倾向的主要原因。我觉得我永远不会完全从 14 年前的精神崩溃中走出来。如果石头掉落水面的力度够大，激起的涟漪会持续一辈子。</p>\n</blockquote>\n<blockquote>\n<p>抗争反而会让情况更糟。与抑郁症和焦虑症共处的秘诀是和它们交朋友，感激它们，才能更好地应对它们。我和它们交朋友的方式是，感谢它们给我一张薄脸皮  。</p>\n</blockquote>\n<blockquote>\n<p>我喜欢乔纳森·罗滕伯格（Jonathan Rottenber）的抑郁症进化理论，他认为抑郁症与无法适应现代环境有关：“<strong>一个古老的情绪系统与一个非凡物种创造的高度新颖的运行环境碰撞了</strong>。”</p>\n</blockquote>\n<blockquote>\n<p>要想感受生命的奇迹，就得感受生命的恐怖。</p>\n</blockquote>\n<blockquote>\n<p>在这个脆弱、碧蓝的小小行星上，包括我在内的70 亿人类，聚集在村镇、城市里，<strong>尽自己最大努力度过 30000 天生命</strong>，微不足道又辉煌壮丽。</p>\n</blockquote>\n<blockquote>\n<p>**人们总认为思想是多么重要，其实感觉也同样重要。**我想读那些让我笑，让我哭，让我恐惧、希望、对空气挥舞拳头的书。我希望一<br>\n本书能够拥抱我，或者抓住我的后脖颈，我甚至不介意它朝我腹部来一拳。因为我们活在世上就为了感觉。</p>\n</blockquote>\n<blockquote>\n<p><strong>我想要感知生命。</strong><br>\n我要读它、写它、感觉它、活它。<br>\n我想要在转瞬即逝的生命里，最大限度地感觉一切能被感觉的。</p>\n</blockquote>\n<blockquote>\n<p>我恨抑郁症。我怕抑郁症，甚至恐惧它。但与此同时，它造就了今天的我。对我而言，<strong>如果抑郁症是我感知生命所要支付的代价，那</strong><br>\n<strong>我心甘情愿承受</strong>。</p>\n</blockquote>\n<blockquote>\n<p><strong>存在着，我心欢喜  。</strong></p>\n</blockquote>\n<h3 id=\"怎样比叔本华快乐一点\">怎样比叔本华快乐一点</h3>\n<blockquote>\n<p>他认为，幸福快乐是不可能的，因为我们设定了种种目标。目标是痛苦的根源。未完成的目标会导致痛苦，而实现了的目标只会带来短暂的满足。</p>\n</blockquote>\n<p>注：”他“指叔本华</p>\n<blockquote>\n<p>叔本华的答案是什么呢？好吧，如果欲望是问题所在，答案就只能是放弃欲望。用他的话来说，痛苦的根源是强烈的意愿。</p>\n</blockquote>\n<blockquote>\n<p>然而，叔本华是个大大的伪君子。他只说不做，言行不一。</p>\n</blockquote>\n<blockquote>\n<p>他素常在上等菜馆里吃得很好；他有过多次色情而不热情的琐屑的恋爱事件；他格外爱争吵，而且异常贪婪。有一回一个上了年纪的女裁缝在他的房间门外边对朋友讲话，惹得他动火，把她扔下楼去，给她造成终身伤残……除对动物的仁慈外，在他一生中很难找到任何美德的痕迹……在其他各方面，他完全是自私的③ 。  ——伯特兰· 罗素，《西方哲学史》</p>\n</blockquote>\n<h3 id=\"时间随想\">时间随想</h3>\n<blockquote>\n<p>对其他事物的觉知，也能拉长时间。冥想就是这个原理。用库尔特·冯内古特的话来说——在“琥珀”状的此刻里，觉知自己。  这听起来简单，然而我们有多少时间是真正<strong>活在当下</strong>的？却又有多少时间浪费在为未来兴奋或担忧，为过去后悔或悼念上？</p>\n</blockquote>\n<blockquote>\n<p>然而，我们似乎明白，把生命变成一场追逐物质的赛跑，只会让它变短。变短的不是时间，而是你对时间的感觉。</p>\n</blockquote>\n<h3 id=\"屏幕上的幻影\">屏幕上的幻影</h3>\n<blockquote>\n<p>意识到<strong>幸福快乐的关键</strong>——或者是人们更渴望的平静的关键——不在于一直拥有快乐的想法。不，那是不可能的。地球上没有一个智慧的头脑会一辈子只有快乐的想法。<strong>关键在于接纳你的想法，一切想法，即使是不好的、糟糕的想法。接纳想法，但不要成为想法本身。</strong></p>\n</blockquote>\n<blockquote>\n<p>比如，你要明白，头脑中出现了一个悲伤的念头，甚至是接连不断的悲伤念头，不等同于你就是一个悲伤的人。你可以穿越暴风雨，<br>\n感受狂风肆虐，但你知道你不是狂风。</p>\n</blockquote>\n<blockquote>\n<p>我们必须允许自己感受它的暴风骤雨，但从始至终明白这都是正常的天气变化。</p>\n</blockquote>\n<p>注：”它“指头脑</p>\n<h3 id=\"渺小\">渺小</h3>\n<blockquote>\n<p>路两旁的房屋还是旧日的橙色砖房。没什么大的改变。你的头脑里经历了天翻地覆的变迁，而世界照旧继续，一无所知。没有什么比这更能让你感觉到自己的渺小和微不足道了。然而，也没有什么比这更令你自由了。接纳你在这个世界里的渺小 。</p>\n</blockquote>\n<p>注：为什么说接纳你的渺小会令你更加自由呢？</p>\n<p>因为接纳渺小会弱化你高强度的自我意识，且因为渺小，所以也就没必要让自己有那么大的负担，然后也就更自由了。</p>\n<h3 id=\"如何生活-我觉得有用但不总是遵循的-40-条建议\">如何生活 我觉得有用但不总是遵循的 40 条建议</h3>\n<blockquote>\n<ol>\n<li>快乐出现的时候，享受快乐。</li>\n<li>小口慢饮，别狼吞虎咽。</li>\n<li>对自己温柔些。少工作，多休息。</li>\n<li>过去的一切你都无法改变。这是基本的物理原理。</li>\n<li>小心星期二和十月。</li>\n<li>库尔特·冯内古特是正确的：“阅读和写作是迄今为止人类发现的最有营养的冥想形式。”</li>\n<li>多倾听，少说话。</li>\n<li>无所事事的时候不要有罪恶感。也许工作比无所事事对世界的危害更大。但可以完善你的无所事事，让它是觉知的。</li>\n<li>觉察到你正在呼吸。</li>\n<li>不论在任何地点，任何时刻，都要试着去发现美。一张面孔、一句诗词、窗外的云、涂鸦画、风力田。美可以净化思想。</li>\n<li>恨是一种毫无意义的情绪。就像为了惩罚一只蜇你的蝎子而吃掉它一样。</li>\n<li>出去跑步，再做点瑜伽。</li>\n<li>中午之前冲个澡。</li>\n<li>遥望天空。提醒自己宇宙是多么浩瀚。抓住每一个感受辽阔悠远的机会，这会让你看见自己的渺小。</li>\n<li>善良。</li>\n<li>要认识到想法只是想法。如果感觉想法不合理，就跟它理论，即使你已找不出道理。你是你头脑的观察者，而非受害者。</li>\n<li>不要漫无目的地看电视。不要漫无目的地上社交网站。要清醒地意识到你正在做什么，为什么而做。别不重视电视，你要更重视<br>\n它，这样你才会少看。无节制的娱乐将使你注意力分散。</li>\n<li>坐下，躺下，不动，什么都不做。观察，倾听你头脑的声音。不去评判头脑里发生的事情，随它吧，就像《冰雪奇缘》里的白<br>\n雪女王一样。</li>\n<li>不要杞人忧天。</li>\n<li>看树，靠近树，种树。（因为树很棒。）</li>\n<li>听 YouTube 上面那个瑜伽教练的话，“走路，好像你在用脚亲吻地球一样。”</li>\n<li>生活，爱，放手。</li>\n<li>酒的数学是乘方运算。你喝得越多，就越想多喝。如果你很难止于一杯，那么更不可能止于三杯。加法就是乘法。</li>\n<li>当心那个缝隙。你现在身处的地方和你想去的地方之间的缝隙。只是想一下它，那个缝隙就会扩大，你就有可能掉到里面去。</li>\n<li>阅读一本书，别去想着要读完它。只是读。享受每个字、句子、段落。别期待它结束，或永不结束。</li>\n<li>在最深层次，宇宙中没有哪种药比善待他人令你感觉更好。</li>\n<li>听听哈姆雷特——文学作品中最著名的抑郁症患者——对罗森克兰茨和吉尔登斯特恩说的话：“世上之事物本无善恶之分，思想使然。”</li>\n<li>允许他人爱你。相信这份爱。为他们活下去，即使你觉得毫无意义。</li>\n<li>你不需要这个世界理解你。没关系的。有的人永远不会真的理解他们没经历过的事情，但有些人会理解，要对理解你的人心怀感<br>\n激。</li>\n<li>儒勒·凡尔纳写过“无限的生命⑤ ”。它是像海一样浩瀚的爱与情感世界。如果我们沉浸其中，将找到无限，找到活下来所需的空<br>\n间。</li>\n<li>凌晨三点不是试图理清人生的时间。</li>\n<li>记住：你一点儿也不怪异。你是人，你的一切行为、感觉都是符合自然的，因为你是自然界的动物。你就是大自然。你是类人猿。你生活在这个世界，这个世界活在你心中。一切都是联结在一起的。</li>\n<li>不要相信什么好坏，输赢，胜负，高潮低谷。在你的最低处和最高处，无论你是快乐还是绝望，平静还是愤怒，都有一个最核心的“你”是始终不变的。这个“你”才是最重要的。</li>\n<li>别担心因绝望而失去的时间。熬过绝望之后，时间的价值将会翻倍。</li>\n<li>对自己透明。给你的头脑建一座玻璃房。观察。</li>\n<li>读艾米莉·狄金森，读格雷厄姆·格林，读伊塔洛·卡尔维诺，读玛雅·安吉罗⑥ 。读一切你想读的，读就好了。书是可能性，是逃跑路线。当你没有选择时，它们给你机会。对于流离失所的头脑来说，每一本书都是一座家园。</li>\n<li>阳光灿烂的日子，能在户外就在户外。</li>\n<li>记住：地球生活的关键是改变。汽车会生锈，书页会发黄，技术会过时，毛毛虫会变蝴蝶，黑夜会变白昼，抑郁也会消散。</li>\n<li>当你感觉忙得没时间休息，就是你最需要找时间休息的时候。</li>\n<li>勇敢，坚强，呼吸，活下去。你会感谢今天的自己。</li>\n</ol>\n</blockquote>\n<h2 id=\"延伸阅读\">延伸阅读</h2>\n<blockquote>\n<p>《深渊：抑郁症疫情的进化起源》（The Depths: The Evolutionary Origins of the Depression Epidemic ），乔纳森·罗滕伯格<br>\n（Jonathan Rottenberg）<br>\n我见过最好的从进化角度看抑郁症的书。</p>\n</blockquote>\n<blockquote>\n<p>《停不下来的人：强迫症和迷失在头脑里的故事》（The Man Who Couldn’t Stop: OCD and the true story of a life lost in th<br>\nought ），大卫·亚当博士（Dr David Adam）</p>\n<p>对强迫症的高度个人化的研究，很精彩，充满对头脑的深刻见解。</p>\n</blockquote>\n<blockquote>\n<p>《和焦虑交朋友：纾解忧虑和恐慌的暖心小书》（Making Friends with Anxiety: A warm, supportive little book to ease worry<br>\nand panic ），莎拉·雷纳（Sarah Rayner）<br>\n简单、易懂的建议，教你如何接纳你的焦虑。</p>\n</blockquote>\n<blockquote>\n<p>《正念禅修：在喧嚣的世界中获取安宁》（Mind-fulness: A practical guide to finding peace in a frantic world ），马克·威廉<br>\n姆斯教授（Professor Mark Williams），丹尼·彭曼博士（Dr Danny Penman）<br>\n对正念持怀疑态度的人大有人在，但作为一种给忙碌生命加注逗号的方式，我认为正念非常有用。这是一本很实用的书。</p>\n</blockquote>\n<blockquote>\n<p>《心智健全的新世界：驯服头脑》（Sane New World: Taming the Mind ），路比·韦克斯（Ruby Wax）<br>\n一本思路清晰、有教育意义的书，强调正念禅修，有着路比·韦克斯一向的妙趣横生。</p>\n</blockquote>\n<blockquote>\n<p>《为什么斑马不得溃疡：压力、压力相关疾病及应对措施经典指南》（Why Zebras Don’t Get Ulcers: The Acclaimed Guide to<br>\nStress,Stress-Related Diseases, and Coping ），罗伯特·M·萨博斯基博士（Dr Robert M. Sapolsky）<br>\n关于压力、压力如何累积、身体，有独特见解。</p>\n</blockquote>\n"},{"title":"JPA&Spring Data笔记整理","url":"/2021/06/27/JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","content":"<h1>JPA&amp;Spring Data笔记整理</h1>\n<p>来自尚硅谷的谷粒商城视频整理</p>\n<span id=\"more\"></span>\n<h2 id=\"JPA\">JPA</h2>\n<h3 id=\"JPA-概述\">JPA_概述</h3>\n<ul>\n<li>JDBC框架</li>\n</ul>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210625141952518.png\" alt=\"image-20210625141952518\"></p>\n<h4 id=\"JPA-是什么\">JPA 是什么</h4>\n<ul>\n<li>\n<p>Java Persistence API：用于对象持久化的 API</p>\n</li>\n<li>\n<p>Java EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层</p>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210625142410350.png\" alt=\"image-20210625142410350\"></p>\n</li>\n</ul>\n<h4 id=\"JPA和Hibernate的关系\">JPA和Hibernate的关系</h4>\n<ul>\n<li>\n<p>JPA 是 hibernate 的一个抽象（就像JDBC和JDBC驱动的关系）：</p>\n<ul>\n<li>\n<p><strong>JPA</strong> <strong>是规范</strong>：JPA 本质上就是一种 ORM 规范，不是ORM 框架 —— 因为 JPA 并未提供 ORM 实现，它只是制订了一些规范，提供了一些编程的 API 接口，但具体实现则由 ORM 厂商提供实现</p>\n</li>\n<li>\n<p><strong>Hibernate</strong> <strong>是实现</strong>：Hibernate 除了作为 ORM 框架之外，它也是一种 JPA 实现</p>\n</li>\n</ul>\n</li>\n<li>\n<p>•从功能上来说， <strong>JPA</strong> <strong>是</strong> <strong>Hibernate</strong> <strong>功能****的一个子集</strong></p>\n</li>\n</ul>\n<h4 id=\"JPA的优势\">JPA的优势</h4>\n<ul>\n<li>\n<p><strong>标准化</strong>: 提供相同的 API，这保证了基于JPA 开发的企业应用能够经过少量的修改就能够在不同的 JPA 框架下运行。</p>\n</li>\n<li>\n<p><strong>简单易用，集成方便</strong>: JPA 的主要目标之一就是提供更加简单的编程模型，在 JPA 框架下创建实体和创建 Java 类一样简单，只需要使用 javax.persistence.Entity 进行注释；JPA 的框架和接口也都非常简单，</p>\n</li>\n<li>\n<p><strong>可媲美JDBC的查询</strong>能力: <strong>JPA的查询语言是面向对象的，JPA定义了独特的JPQL</strong>，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。</p>\n</li>\n<li>\n<p><strong>支持面向对象的高级特性</strong>: JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，最大限度的使用面向对象的模型</p>\n</li>\n</ul>\n<h3 id=\"HelloWorld\">HelloWorld</h3>\n<h4 id=\"使用JPA持久化对象的步骤\">使用JPA持久化对象的步骤</h4>\n<ul>\n<li>创建 persistence.xml, 在这个文件中配置持久化单元\n<ul>\n<li>需要指定跟哪个数据库进行交互;</li>\n<li>需要指定 JPA 使用哪个持久化的框架以及配置该框架的基本属性</li>\n</ul>\n</li>\n<li>创建实体类, 使用 annotation 来描述实体类跟数据库表之间的映射关系.</li>\n<li>使用 JPA API 完成数据增加、删除、修改和查询操作\n<ul>\n<li>创建 EntityManagerFactory (对应 Hibernate 中的 SessionFactory);</li>\n<li>创建 EntityManager (对应 Hibernate 中的Session);</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"代码相关\">代码相关</h4>\n<p>配置文件：persistence.xml(<strong>JPA 规范要求在类路径的 META-INF 目录下放置persistence.xml，文件的名称是固定的</strong>)</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">            配置使用什么 ORM 产品来作为 JPA 的实现 </span></span><br><span class=\"line\"><span class=\"comment\">            1. 实际上配置的是  javax.persistence.spi.PersistenceProvider 接口的实现类</span></span><br><span class=\"line\"><span class=\"comment\">            2. 若 JPA 项目中只有一个 JPA 的实现产品, 则也可以不配置该节点. </span></span><br><span class=\"line\"><span class=\"comment\">            --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">provider</span>&gt;</span>org.hibernate.ejb.HibernatePersistence<span class=\"tag\">&lt;/<span class=\"name\">provider</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!-- 连接数据库的基本信息 --&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;javax.persistence.jdbc.driver&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;javax.persistence.jdbc.url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql:///jpa&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;javax.persistence.jdbc.user&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;javax.persistence.jdbc.password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1230&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!-- 配置 JPA 实现产品的基本属性. 配置 hibernate 的基本属性 --&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.format_sql&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.show_sql&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    \t\t<span class=\"comment\">&lt;!-- 生成数据表策略 --&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;update&quot;</span>/&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t    <span class=\"comment\">&lt;!-- 添加持久化类 --&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">class</span>&gt;</span>com.atguigu.jpa.helloworld.Customer<span class=\"tag\">&lt;/<span class=\"name\">class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>持久化类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Table(name=&quot;JPA_CUTOMERS&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String lastName;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String email;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Date createdTime;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Date birth;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue(strategy=GenerationType.AUTO)</span></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Column(name=&quot;LAST_NAME&quot;,length=50,nullable=false)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> lastName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLastName</span><span class=\"params\">(String lastName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.lastName = lastName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Temporal(TemporalType.TIMESTAMP)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getCreatedTime</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> createdTime;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCreatedTime</span><span class=\"params\">(Date createdTime)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.createdTime = createdTime;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Temporal(TemporalType.DATE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getBirth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> birth;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBirth</span><span class=\"params\">(Date birth)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.birth = birth;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 创建 EntitymanagerFactory</span></span><br><span class=\"line\">String persistenceUnitName = <span class=\"string\">&quot;jpa-1&quot;</span>;</span><br><span class=\"line\">EntityManagerFactory entityManagerFactory = </span><br><span class=\"line\">    Persistence.createEntityManagerFactory(persistenceUnitName);</span><br><span class=\"line\"><span class=\"comment\">//2. 创建 EntityManager. 类似于 Hibernate 的 SessionFactory</span></span><br><span class=\"line\">EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3. 开启事务</span></span><br><span class=\"line\">EntityTransaction transaction = entityManager.getTransaction();</span><br><span class=\"line\">transaction.begin();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4. 进行持久化操作</span></span><br><span class=\"line\">Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">customer.setAge(<span class=\"number\">12</span>);</span><br><span class=\"line\">customer.setEmail(<span class=\"string\">&quot;tom@atguigu.com&quot;</span>);</span><br><span class=\"line\">customer.setLastName(<span class=\"string\">&quot;Tom&quot;</span>);</span><br><span class=\"line\">customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\"></span><br><span class=\"line\">entityManager.persist(customer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5. 提交事务</span></span><br><span class=\"line\">transaction.commit();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//6. 关闭 EntityManager</span></span><br><span class=\"line\">entityManager.close();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//7. 关闭 EntityManagerFactory</span></span><br><span class=\"line\">entityManagerFactory.close();\t\t</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-基本注解\">JPA 基本注解</h3>\n<ul>\n<li>\n<p><strong>@Entity</strong>:标注用于实体类声明语句之前，<strong>指出该****Java</strong> <strong>类****为实体类</strong>，<strong>将映射到指定的数据库表</strong>。如声明一个实体类 Customer，它将映射到数据库中的 customer 表上。</p>\n</li>\n<li>\n<p><strong>@Table</strong>:•标注的常用选项是 <strong>name</strong>，用于指明数据库的表名</p>\n</li>\n<li>\n<p><strong>@Id</strong>:</p>\n<ul>\n<li>@Id用于声明一个实体类的属性映射为数据库的<strong>主键列</strong>。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。</li>\n<li>@Id标注也可置于属性的getter方法之前。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210625150906869.png\" alt=\"image-20210625150906869\"></p>\n<ul>\n<li>\n<p><strong>@GeneratedValue</strong>:用于标注主键的生成策略，通过 strategy 属性指定。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略</p>\n<ul>\n<li>IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式；</li>\n<li>AUTO： JPA自动选择合适的策略，是默认选项；</li>\n<li>SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式</li>\n<li>TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。</li>\n</ul>\n</li>\n<li>\n<p>@Basic:表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的 getXxxx() 方法,默认即为@Basic。</p>\n<ul>\n<li>fetch: 表示该属性的读取策略,有 EAGER 和 LAZY 两种,分别表示主支抓取和延迟加载,默认为 EAGER.</li>\n<li>optional:表示该属性是否允许为null, 默认为true</li>\n</ul>\n</li>\n<li>\n<p>@Column：</p>\n</li>\n</ul>\n<h3 id=\"Transient注解\"><strong>@Transient</strong>注解</h3>\n<ul>\n<li>\n<p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.</p>\n</li>\n<li>\n<p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic</p>\n</li>\n</ul>\n<h3 id=\"Temporal\">**@**Temporal</h3>\n<ul>\n<li>\n<p>在核心的 Java API 中并没有定义 Date 类型的精度(temporal precision).  而在数据库中,表示 Date 类型的数据有 DATE, TIME, 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者 兼备). 在进行属性映射时可使用@Temporal注解来调整精度.</p>\n</li>\n<li>\n<p>mysql的5种日期类型</p>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210625152114289.png\" alt=\"image-20210625152114289\"></p>\n</li>\n<li>\n<p>代码示例</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Customer类定义中截取</span></span><br><span class=\"line\"><span class=\"meta\">@Temporal(TemporalType.TIMESTAMP)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getCreatedTime</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createdTime;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCreatedTime</span><span class=\"params\">(Date createdTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.createdTime = createdTime;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//数据库中会变成datetime类型</span></span><br><span class=\"line\"><span class=\"meta\">@Temporal(TemporalType.DATE)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getBirth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> birth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//数据库中会变成date类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBirth</span><span class=\"params\">(Date birth)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.birth = birth;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用-table-来生成主键详解\">用 table 来生成主键详解</h3>\n<h3 id=\"JPA-EntityManager-1\">JPA_EntityManager(1)</h3>\n<h4 id=\"Persistence\">Persistence</h4>\n<ul>\n<li>\n<p>Persistence 类是<strong>用于获取 EntityManagerFactory 实例</strong>。该类包含一个名为 createEntityManagerFactory 的 静态方法 。</p>\n</li>\n<li>\n<p>createEntityManagerFactory 方法有如下两个重载版本。</p>\n<ul>\n<li>带有一个参数的方法以 JPA 配置文件 persistence.xml 中的持久化单元名为参数</li>\n<li>带有两个参数的方法：前一个参数含义相同，后一个参数 Map类型，用于设置 JPA 的相关属性，这时将忽略其它地方设置的属性。Map 对象的属性名必须是 JPA 实现库提供商的名字空间约定的属性名。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 创建 EntitymanagerFactory</span></span><br><span class=\"line\">String persistenceUnitName = <span class=\"string\">&quot;jpa-1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, Object&gt; properites = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">properites.put(<span class=\"string\">&quot;hibernate.show_sql&quot;</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">EntityManagerFactory entityManagerFactory = </span><br><span class=\"line\">    <span class=\"comment\">//Persistence.createEntityManagerFactory(persistenceUnitName);</span></span><br><span class=\"line\">    Persistence.createEntityManagerFactory(persistenceUnitName, properites);</span><br></pre></td></tr></table></figure>\n<h4 id=\"EntityManagerFactory\">EntityManagerFactory</h4>\n<ul>\n<li>EntityManagerFactory 接口主要用来创建 EntityManager 实例。该接口约定了如下4个方法：\n<ul>\n<li><strong>createEntityManager()</strong>：用于创建实体管理器对象实例。</li>\n<li>createEntityManager(Map map)：用于创建实体管理器对象实例的重载方法，Map 参数用于提供 EntityManager 的属性。</li>\n<li>isOpen()：检查 EntityManagerFactory 是否处于打开状态。实体管理器工厂创建后一直处于打开状态，除非调用close()方法将其关闭。</li>\n<li><strong>close()</strong>：关闭 EntityManagerFactory 。 EntityManagerFactory 关闭后将释放所有资源，isOpen()方法测试将返回 false，其它方法将不能调用，否则将导致IllegalStateException异常。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2. 创建 EntityManager. 类似于 Hibernate 的 SessionFactory</span></span><br><span class=\"line\">EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//7. 关闭 EntityManagerFactory</span></span><br><span class=\"line\">entityManagerFactory.close();</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-EntityManager-2\">JPA_EntityManager(2)</h3>\n<ul>\n<li>首先搭建测试环境</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JPATest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> EntityManagerFactory entityManagerFactory;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> EntityManager entityManager;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> EntityTransaction transaction;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Before</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tentityManagerFactory = Persistence.createEntityManagerFactory(<span class=\"string\">&quot;jpa-1&quot;</span>);</span><br><span class=\"line\">\t\tentityManager = entityManagerFactory.createEntityManager();</span><br><span class=\"line\">\t\ttransaction = entityManager.getTransaction();</span><br><span class=\"line\">\t\ttransaction.begin();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@After</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\ttransaction.commit();</span><br><span class=\"line\">\t\tentityManager.close();</span><br><span class=\"line\">\t\tentityManagerFactory.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"find方法\">find方法</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类似于 hibernate 中 Session 的 get 方法. </span></span><br><span class=\"line\"><span class=\"comment\">//find方法会立即发送select语句</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testFind</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Customer customer = entityManager.find(Customer.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-------------------------------------&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(customer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"getReference方法\">getReference方法</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类似于 hibernate 中 Session 的 load 方法，</span></span><br><span class=\"line\"><span class=\"comment\">//先返回一个代理对象，在真正使用时在发送select语句</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testGetReference</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = entityManager.getReference(Customer.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//会打印一个代理对象</span></span><br><span class=\"line\">    System.out.println(customer.getClass().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-------------------------------------&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//把下面两行的注释取消，会出现软加载异常的问题。因为此时的代理对象不再受到entityManager的管理，也就无法发送select语句</span></span><br><span class=\"line\">    <span class=\"comment\">//\t\ttransaction.commit();</span></span><br><span class=\"line\">    <span class=\"comment\">//\t\tentityManager.close();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(customer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"persist方法\"><strong>persist</strong>方法</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类似于 hibernate 的 save 方法. 使对象由临时状态变为持久化状态. </span></span><br><span class=\"line\"><span class=\"comment\">//和 hibernate 的 save 方法的不同之处: 若对象有 id, 则不能执行 insert 操作, 而会抛出异常. 而hibernate不会</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPersistence</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    customer.setAge(<span class=\"number\">15</span>);</span><br><span class=\"line\">    customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setEmail(<span class=\"string\">&quot;bb@163.com&quot;</span>);</span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;BB&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//若对象有 id, 则不能执行 insert 操作, 而会抛出异常.</span></span><br><span class=\"line\">\t<span class=\"comment\">//customer.setId(100); </span></span><br><span class=\"line\">    entityManager.persist(customer);</span><br><span class=\"line\">    System.out.println(customer.getId());<span class=\"comment\">//打印id，使对象由临时状态变为持久化状态</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"remove方法\">remove方法</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类似于 hibernate 中 Session 的 delete 方法. 把对象对应的记录从数据库中移除</span></span><br><span class=\"line\"><span class=\"comment\">//但注意: 该方法只能移除 持久化 对象. 而 hibernate 的 delete 方法实际上还可以移除 游离对象.</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testRemove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//此时创建了一个游离对象，但不能删除</span></span><br><span class=\"line\">    <span class=\"comment\">//\tCustomer customer = new Customer();</span></span><br><span class=\"line\">    <span class=\"comment\">//\tcustomer.setId(2);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Customer customer = entityManager.find(Customer.class, <span class=\"number\">2</span>);</span><br><span class=\"line\">    entityManager.remove(customer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"jpa角度下对象分为四种状态\">jpa角度下对象分为四种状态</h4>\n<p><strong>新建状态</strong>:   新创建的对象，尚未拥有持久性主键。<br>\n<strong>持久化状态</strong>：已经【拥有持久性主键】（数据库中有该对象）并和持久化【建立了上下文环境】（受到entityManager管理）<br>\n<strong>游离状态</strong>：拥有持久化主键，但是没有与持久化建立上下文环境<br>\n<strong>删除状态</strong>:  拥有持久化主键，已经和持久化建立上下文环境，但是从数据库中删除。</p>\n<h3 id=\"JPA-EntityManager-3-–merge方法\">JPA_EntityManager(3)–merge方法</h3>\n<ul>\n<li>merge方法：用于处理 Entity 的同步。即数据库的插入和更新操作</li>\n</ul>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210625161039941.png\" alt=\"image-20210625161039941\"></p>\n<ul>\n<li>情况一（共有4种）：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 总的来说: 类似于 hibernate Session 的 saveOrUpdate 方法.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">//1. 若传入的是一个临时对象</span></span><br><span class=\"line\"><span class=\"comment\">//会创建一个新的对象, 把临时对象的属性复制到新的对象中, 然后对新的对象执行持久化操作. 所以</span></span><br><span class=\"line\"><span class=\"comment\">//新的对象中有 id, 但以前的临时对象中没有 id. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testMerge1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    customer.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">    customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setEmail(<span class=\"string\">&quot;cc@163.com&quot;</span>);</span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;CC&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//这里会对customer2发送一个insert语句</span></span><br><span class=\"line\">    Customer customer2 = entityManager.merge(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;customer#id:&quot;</span> + customer.getId());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;customer2#id:&quot;</span> + customer2.getId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>情况二</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//若传入的是一个游离对象, 即传入的对象有 OID. </span></span><br><span class=\"line\"><span class=\"comment\">//1. 若在 EntityManager 缓存中没有该对象</span></span><br><span class=\"line\"><span class=\"comment\">//2. 若在数据库中也没有对应的记录</span></span><br><span class=\"line\"><span class=\"comment\">//3. JPA 会创建一个新的对象, 然后把当前游离对象的属性复制到新创建的对象中</span></span><br><span class=\"line\"><span class=\"comment\">//4. 对新创建的对象执行 insert 操作. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testMerge2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    customer.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">    customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setEmail(<span class=\"string\">&quot;dd@163.com&quot;</span>);</span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;DD&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    customer.setId(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Customer customer2 = entityManager.merge(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;customer#id:&quot;</span> + customer.getId());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;customer2#id:&quot;</span> + customer2.getId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>情况三</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//若传入的是一个游离对象, 即传入的对象有 OID. </span></span><br><span class=\"line\"><span class=\"comment\">//1. 若在 EntityManager 缓存中没有该对象</span></span><br><span class=\"line\"><span class=\"comment\">//2. 若在数据库中也有对应的记录</span></span><br><span class=\"line\"><span class=\"comment\">//3. JPA 会查询对应的记录, 然后返回该记录对一个的对象, 再然后会把游离对象的属性复制到查询到的对象中.</span></span><br><span class=\"line\"><span class=\"comment\">//4. 对查询到的对象执行 update 操作. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testMerge3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    customer.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">    customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setEmail(<span class=\"string\">&quot;ee@163.com&quot;</span>);</span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;EE&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    customer.setId(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Customer customer2 = entityManager.merge(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(customer == customer2); <span class=\"comment\">//false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>情况四</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//若传入的是一个游离对象, 即传入的对象有 OID. </span></span><br><span class=\"line\"><span class=\"comment\">//1. 若在 EntityManager 缓存中有对应的对象</span></span><br><span class=\"line\"><span class=\"comment\">//2. JPA 会把游离对象的属性复制到查询到EntityManager 缓存中的对象中.</span></span><br><span class=\"line\"><span class=\"comment\">//3. EntityManager 缓存中的对象执行 UPDATE. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testMerge4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    customer.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">    customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setEmail(<span class=\"string\">&quot;dd@163.com&quot;</span>);</span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;DD&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    customer.setId(<span class=\"number\">4</span>);</span><br><span class=\"line\">    Customer customer2 = entityManager.find(Customer.class, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    entityManager.merge(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(customer == customer2); <span class=\"comment\">//false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-EntityManager-4\">JPA_EntityManager(4)</h3>\n<h4 id=\"flush方法\">flush方法</h4>\n<p>强制发送sql语句，使数据表中的记录和内存中的对象一致</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 同 hibernate 中 Session 的 flush 方法. </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testFlush</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = entityManager.find(Customer.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">    System.out.println(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;AA&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//强制发送update语句，否则，该语句会在提交事务的时候再发送</span></span><br><span class=\"line\">    entityManager.flush();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"refresh方法\">refresh方法</h4>\n<p>用数据库实体记录的值更新实体对象的状态，即更新实例的属性值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 同 hibernate 中 Session 的 refresh 方法. </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testRefresh</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = entityManager.find(Customer.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//由于一级缓存的存在，只会发送一条sql</span></span><br><span class=\"line\">    customer = entityManager.find(Customer.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//重新获取一下数据库中的记录，看是不是还是和内存中的一样，也就是会发送一条select语句</span></span><br><span class=\"line\">    entityManager.refresh(customer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"clear方法\">clear方法</h4>\n<p>清除持久上下文环境，断开所有关联的实体。如果这时还有未提交的更新则会被撤消。</p>\n<h3 id=\"JPA-EntityTransaction\">JPA_EntityTransaction</h3>\n<ul>\n<li>\n<p>EntityTransaction 接口用来管理资源层实体管理器的事务操作。</p>\n</li>\n<li>\n<p>通过调用实体管理器的getTransaction方法 获得其实例。</p>\n</li>\n<li>\n<p>API</p>\n</li>\n</ul>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210625164534391.png\" alt=\"image-20210625164534391\"></p>\n<h3 id=\"JPA-映射单向多对一的关联关系\">JPA_映射单向多对一的关联关系</h3>\n<ul>\n<li>Order对象（多）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Table(name=&quot;JPA_ORDERS&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String orderName;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Customer customer;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@GeneratedValue</span></span><br><span class=\"line\">\t<span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(name=&quot;ORDER_NAME&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getOrderName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> orderName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOrderName</span><span class=\"params\">(String orderName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.orderName = orderName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//映射单向 n-1 的关联关系</span></span><br><span class=\"line\">\t<span class=\"comment\">//使用 @ManyToOne 来映射多对一的关联关系</span></span><br><span class=\"line\">\t<span class=\"comment\">//使用 @JoinColumn 来映射外键. </span></span><br><span class=\"line\">\t<span class=\"comment\">//可使用 @ManyToOne 的 fetch 属性来修改默认的关联属性的加载策略</span></span><br><span class=\"line\">\t<span class=\"meta\">@JoinColumn(name=&quot;CUSTOMER_ID&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@ManyToOne(fetch=FetchType.LAZY)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getCustomer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCustomer</span><span class=\"params\">(Customer customer)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.customer = customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Customer（一）</li>\n</ul>\n<p>注：类定义中不用加</p>\n<blockquote>\n<p>private Set<Order> orders = new HashSet&lt;&gt;();</p>\n</blockquote>\n<ul>\n<li>代码示例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 保存多对一时, 建议先保存 1 的一端, 后保存 n 的一端, 这样不会多出额外的 UPDATE 语句.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testManyToOnePersist</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    customer.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">    customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setEmail(<span class=\"string\">&quot;gg@163.com&quot;</span>);</span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;GG&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Order order1 = <span class=\"keyword\">new</span> Order();</span><br><span class=\"line\">    order1.setOrderName(<span class=\"string\">&quot;G-GG-1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Order order2 = <span class=\"keyword\">new</span> Order();</span><br><span class=\"line\">    order2.setOrderName(<span class=\"string\">&quot;G-GG-2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置关联关系</span></span><br><span class=\"line\">    order1.setCustomer(customer);</span><br><span class=\"line\">    order2.setCustomer(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行保存操作</span></span><br><span class=\"line\">    entityManager.persist(order1);</span><br><span class=\"line\">    entityManager.persist(order2);</span><br><span class=\"line\"></span><br><span class=\"line\">    entityManager.persist(customer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认情况下, 使用左外连接的方式来获取 n 的一端的对象和其关联的 1 的一端的对象. </span></span><br><span class=\"line\"><span class=\"comment\">//可使用 @ManyToOne 的 fetch 属性来修改默认的关联属性的加载策略</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testManyToOneFind</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Order order = entityManager.find(Order.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">    System.out.println(order.getOrderName());</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(order.getCustomer().getLastName());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不能直接删除 1 的一端,会报异常，因为有外键约束. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testManyToOneRemove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//\t\tOrder order = entityManager.find(Order.class, 1);</span></span><br><span class=\"line\">    <span class=\"comment\">//\t\tentityManager.remove(order);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Customer customer = entityManager.find(Customer.class, <span class=\"number\">7</span>);</span><br><span class=\"line\">    entityManager.remove(customer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testManyToOneUpdate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Order order = entityManager.find(Order.class, <span class=\"number\">2</span>);</span><br><span class=\"line\">    order.getCustomer().setLastName(<span class=\"string\">&quot;FFF&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-映射单向一对多的关联关系\">JPA_映射单向一对多的关联关系</h3>\n<ul>\n<li>将Order类中的customer属性删除；在Customer中添加private Set<Order> orders = new HashSet&lt;&gt;();</li>\n</ul>\n<p>Customer中的修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//映射单向 1-n 的关联关系</span></span><br><span class=\"line\"><span class=\"comment\">//使用 @OneToMany 来映射 1-n 的关联关系</span></span><br><span class=\"line\"><span class=\"comment\">//使用 @JoinColumn 来映射外键列的名称，该外键列仍然会显示在order表中</span></span><br><span class=\"line\"><span class=\"comment\">//可以使用 @OneToMany 的 fetch 属性来修改默认的加载策略</span></span><br><span class=\"line\"><span class=\"comment\">//可以通过 @OneToMany 的 cascade 属性来修改默认的删除策略. </span></span><br><span class=\"line\"><span class=\"comment\">//注意: 若在 1 的一端的 @OneToMany 中使用 mappedBy 属性, 则 @OneToMany 端就不能再使用 @JoinColumn 属性了. </span></span><br><span class=\"line\"><span class=\"meta\">@JoinColumn(name=&quot;CUSTOMER_ID&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany(fetch=FetchType.LAZY,cascade=&#123;CascadeType.REMOVE&#125;,mappedBy=&quot;customer&quot;)</span><span class=\"comment\">//CascadeType.REMOVE:级联删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Set&lt;Order&gt; <span class=\"title\">getOrders</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> orders;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOrders</span><span class=\"params\">(Set&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.orders = orders;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单向 1-n 关联关系执行保存时, 一定会多出 UPDATE 语句(因为order不再维护关联关系，则order在insert时不会再设置外键列，在update时才会设置外键列).</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneToManyPersist</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    customer.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">    customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setEmail(<span class=\"string\">&quot;mm@163.com&quot;</span>);</span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;MM&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Order order1 = <span class=\"keyword\">new</span> Order();</span><br><span class=\"line\">    order1.setOrderName(<span class=\"string\">&quot;O-MM-1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Order order2 = <span class=\"keyword\">new</span> Order();</span><br><span class=\"line\">    order2.setOrderName(<span class=\"string\">&quot;O-MM-2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//建立关联关系</span></span><br><span class=\"line\">    customer.getOrders().add(order1);</span><br><span class=\"line\">    customer.getOrders().add(order2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行保存操作</span></span><br><span class=\"line\">    entityManager.persist(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    entityManager.persist(order1);</span><br><span class=\"line\">    entityManager.persist(order2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认对关联的多的一方使用懒加载的加载策略. </span></span><br><span class=\"line\"><span class=\"comment\">//可以使用 @OneToMany 的 fetch 属性来修改默认的加载策略</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneToManyFind</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = entityManager.find(Customer.class, <span class=\"number\">9</span>);</span><br><span class=\"line\">    System.out.println(customer.getLastName());</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(customer.getOrders().size());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认情况下, 若删除 1 的一端, 则会先把关联的 n 的一端的外键置空, 然后进行删除. </span></span><br><span class=\"line\"><span class=\"comment\">//可以通过 @OneToMany 的 cascade 属性来修改默认的删除策略. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneToManyRemove</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = entityManager.find(Customer.class, <span class=\"number\">8</span>);</span><br><span class=\"line\">    entityManager.remove(customer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testUpdate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = entityManager.find(Customer.class, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    customer.getOrders().iterator().next().setOrderName(<span class=\"string\">&quot;O-XXX-10&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-映射双向一对多的关联关系\">JPA_映射双向一对多的关联关系</h3>\n<p>Customer类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Table(name=&quot;JPA_CUTOMERS&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String lastName;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String email;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Date createdTime;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Date birth;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Customer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated constructor stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Customer</span><span class=\"params\">(String lastName, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.lastName = lastName;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Set&lt;Order&gt; orders = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\t@TableGenerator(name=&quot;ID_GENERATOR&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\ttable=&quot;jpa_id_generators&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tpkColumnName=&quot;PK_NAME&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tpkColumnValue=&quot;CUSTOMER_ID&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tvalueColumnName=&quot;PK_VALUE&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tallocationSize=100)</span></span><br><span class=\"line\"><span class=\"comment\">//\t@GeneratedValue(strategy=GenerationType.TABLE,generator=&quot;ID_GENERATOR&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@GeneratedValue(strategy=GenerationType.AUTO)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(name=&quot;LAST_NAME&quot;,length=50,nullable=false)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> lastName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLastName</span><span class=\"params\">(String lastName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.lastName = lastName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> email;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(String email)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Temporal(TemporalType.TIMESTAMP)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getCreatedTime</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> createdTime;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCreatedTime</span><span class=\"params\">(Date createdTime)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.createdTime = createdTime;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Temporal(TemporalType.DATE)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getBirth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> birth;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBirth</span><span class=\"params\">(Date birth)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.birth = birth;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//映射单向 1-n 的关联关系</span></span><br><span class=\"line\">\t<span class=\"comment\">//使用 @OneToMany 来映射 1-n 的关联关系</span></span><br><span class=\"line\">\t<span class=\"comment\">//使用 @JoinColumn 来映射外键列的名称</span></span><br><span class=\"line\">\t<span class=\"comment\">//可以使用 @OneToMany 的 fetch 属性来修改默认的加载策略</span></span><br><span class=\"line\">\t<span class=\"comment\">//可以通过 @OneToMany 的 cascade 属性来修改默认的删除策略. </span></span><br><span class=\"line\">\t<span class=\"comment\">//注意: 若在 1 的一端的 @OneToMany 中使用 mappedBy 属性, 则 @OneToMany 端就不能再使用 @JoinColumn 属性了. </span></span><br><span class=\"line\"><span class=\"comment\">//\t@JoinColumn(name=&quot;CUSTOMER_ID&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@OneToMany(fetch=FetchType.LAZY,cascade=&#123;CascadeType.REMOVE&#125;,mappedBy=&quot;customer&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Set&lt;Order&gt; <span class=\"title\">getOrders</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> orders;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOrders</span><span class=\"params\">(Set&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.orders = orders;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Customer [id=&quot;</span> + id + <span class=\"string\">&quot;, lastName=&quot;</span> + lastName + <span class=\"string\">&quot;, email=&quot;</span></span><br><span class=\"line\">\t\t\t\t+ email + <span class=\"string\">&quot;, age=&quot;</span> + age + <span class=\"string\">&quot;, createdTime=&quot;</span> + createdTime</span><br><span class=\"line\">\t\t\t\t+ <span class=\"string\">&quot;, birth=&quot;</span> + birth + <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Order类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Table(name=&quot;JPA_ORDERS&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String orderName;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Customer customer;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@GeneratedValue</span></span><br><span class=\"line\">\t<span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(name=&quot;ORDER_NAME&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getOrderName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> orderName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOrderName</span><span class=\"params\">(String orderName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.orderName = orderName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//映射单向 n-1 的关联关系</span></span><br><span class=\"line\">\t<span class=\"comment\">//使用 @ManyToOne 来映射多对一的关联关系</span></span><br><span class=\"line\">\t<span class=\"comment\">//使用 @JoinColumn 来映射外键. </span></span><br><span class=\"line\">\t<span class=\"comment\">//可使用 @ManyToOne 的 fetch 属性来修改默认的关联属性的加载策略</span></span><br><span class=\"line\">\t<span class=\"meta\">@JoinColumn(name=&quot;CUSTOMER_ID&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@ManyToOne(fetch=FetchType.LAZY)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getCustomer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCustomer</span><span class=\"params\">(Customer customer)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.customer = customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>代码示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//若是双向 1-n 的关联关系, 执行保存时</span></span><br><span class=\"line\"><span class=\"comment\">//若先保存 n 的一端, 再保存 1 的一端, 默认情况下, 会多出 4 条 UPDATE 语句(另外多出来的两条是因为Customer也要维护关联关系).</span></span><br><span class=\"line\"><span class=\"comment\">//若先保存 1 的一端, 则会多出 2 条 UPDATE 语句</span></span><br><span class=\"line\"><span class=\"comment\">//在进行双向 1-n 关联关系时, 建议使用 n 的一方来维护关联关系, 而 1 的一方不维护关联系, 这样会有效的减少 SQL 语句. </span></span><br><span class=\"line\"><span class=\"comment\">//注意: 若在 1 的一端的 @OneToMany 中使用 mappedBy 属性（表示1的一端放弃维护关联关系）, 则 @OneToMany 端就不能再使用 @JoinColumn 属性了. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneToManyPersist</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    customer.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">    customer.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setCreatedTime(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    customer.setEmail(<span class=\"string\">&quot;mm@163.com&quot;</span>);</span><br><span class=\"line\">    customer.setLastName(<span class=\"string\">&quot;MM&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Order order1 = <span class=\"keyword\">new</span> Order();</span><br><span class=\"line\">    order1.setOrderName(<span class=\"string\">&quot;O-MM-1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Order order2 = <span class=\"keyword\">new</span> Order();</span><br><span class=\"line\">    order2.setOrderName(<span class=\"string\">&quot;O-MM-2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//建立关联关系</span></span><br><span class=\"line\">    customer.getOrders().add(order1);</span><br><span class=\"line\">    customer.getOrders().add(order2);</span><br><span class=\"line\"></span><br><span class=\"line\">    order1.setCustomer(customer);</span><br><span class=\"line\">    order2.setCustomer(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行保存操作</span></span><br><span class=\"line\">    entityManager.persist(customer);</span><br><span class=\"line\"></span><br><span class=\"line\">    entityManager.persist(order1);</span><br><span class=\"line\">    entityManager.persist(order2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-映射双向一对一的关联关系\">JPA_映射双向一对一的关联关系</h3>\n<p>建两个类，部门和经理，一个部门只能有一个经理，一个经理只能管一个部门</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Table(name=&quot;JPA_DEPARTMENTS&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String deptName;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Manager mgr;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@GeneratedValue</span></span><br><span class=\"line\">\t<span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(name=&quot;DEPT_NAME&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDeptName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> deptName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDeptName</span><span class=\"params\">(String deptName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.deptName = deptName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//使用 @OneToOne 来映射 1-1 关联关系。</span></span><br><span class=\"line\">\t<span class=\"comment\">//若需要在当前数据表中添加主键则需要使用 @JoinColumn 来进行映射. 注意, 1-1 关联关系, 所以需要添加 unique=true</span></span><br><span class=\"line\">\t<span class=\"meta\">@JoinColumn(name=&quot;MGR_ID&quot;, unique=true)</span></span><br><span class=\"line\">\t<span class=\"meta\">@OneToOne(fetch=FetchType.LAZY)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Manager <span class=\"title\">getMgr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mgr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMgr</span><span class=\"params\">(Manager mgr)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.mgr = mgr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Table(name=&quot;JPA_MANAGERS&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String mgrName;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Department dept;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@GeneratedValue</span></span><br><span class=\"line\">\t<span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(name=&quot;MGR_NAME&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMgrName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mgrName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMgrName</span><span class=\"params\">(String mgrName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.mgrName = mgrName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//对于不维护关联关系, 没有外键的一方, 使用 @OneToOne 来进行映射, 建议设置 mappedBy=true</span></span><br><span class=\"line\">\t<span class=\"meta\">@OneToOne(mappedBy=&quot;mgr&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Department <span class=\"title\">getDept</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> dept;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDept</span><span class=\"params\">(Department dept)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.dept = dept;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>代码示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//双向 1-1 的关联关系, 建议先保存不维护关联关系的一方, 即没有外键的一方, 这样不会多出 UPDATE 语句.</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneToOnePersistence</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Manager mgr = <span class=\"keyword\">new</span> Manager();</span><br><span class=\"line\">    mgr.setMgrName(<span class=\"string\">&quot;M-BB&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Department dept = <span class=\"keyword\">new</span> Department();</span><br><span class=\"line\">    dept.setDeptName(<span class=\"string\">&quot;D-BB&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置关联关系</span></span><br><span class=\"line\">    mgr.setDept(dept);</span><br><span class=\"line\">    dept.setMgr(mgr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行保存操作</span></span><br><span class=\"line\">    entityManager.persist(mgr);</span><br><span class=\"line\">    entityManager.persist(dept);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1.默认情况下, 若获取维护关联关系的一方, 则会通过左外连接获取其关联的对象. </span></span><br><span class=\"line\"><span class=\"comment\">//但可以通过 @OntToOne 的 fetch 属性来修改加载策略(会减少一条select语句).</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneToOneFind</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Department dept = entityManager.find(Department.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">    System.out.println(dept.getDeptName());</span><br><span class=\"line\">    System.out.println(dept.getMgr().getClass().getName());<span class=\"comment\">//此时得到的Manager是一个代理类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. 默认情况下, 若获取不维护关联关系的一方, 则也会通过左外连接获取其关联的对象. </span></span><br><span class=\"line\"><span class=\"comment\">//可以通过 @OneToOne 的 fetch 属性来修改加载策略. 但依然会再发送 SQL 语句来初始化其关联的对象</span></span><br><span class=\"line\"><span class=\"comment\">//这说明在不维护关联关系的一方, 不建议修改 fetch 属性.</span></span><br><span class=\"line\"><span class=\"comment\">//因为Manager没有外键，他必须要先查另一张表来获取信息</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOneToOneFind2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Manager mgr = entityManager.find(Manager.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">    System.out.println(mgr.getMgrName());</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(mgr.getDept().getClass().getName());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-映射双向多对多的关联关系\">JPA_映射双向多对多的关联关系</h3>\n<h3 id=\"JPA-二级缓存\">JPA_二级缓存</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果利用的是一级缓存，会发送两条sql语句</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSecondLevelCache</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Customer customer1 = entityManager.find(Customer.class, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">    entityManager.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    entityManager = entityManagerFactory.createEntityManager();</span><br><span class=\"line\">    transaction = entityManager.getTransaction();</span><br><span class=\"line\">    transaction.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    Customer customer2 = entityManager.find(Customer.class, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>persistence.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">  配置二级缓存的策略 </span></span><br><span class=\"line\"><span class=\"comment\">  ALL：所有的实体类都被缓存</span></span><br><span class=\"line\"><span class=\"comment\">  NONE：所有的实体类都不被缓存. </span></span><br><span class=\"line\"><span class=\"comment\">  ENABLE_SELECTIVE：标识 @Cacheable(true) 注解的实体类将被缓存</span></span><br><span class=\"line\"><span class=\"comment\">  DISABLE_SELECTIVE：缓存除标识 @Cacheable(false) 以外的所有实体类</span></span><br><span class=\"line\"><span class=\"comment\">  UNSPECIFIED：默认值，JPA 产品默认值将被使用</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">shared-cache-mode</span>&gt;</span>ENABLE_SELECTIVE<span class=\"tag\">&lt;/<span class=\"name\">shared-cache-mode</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 二级缓存相关 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 启用二级缓存 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.cache.use_second_level_cache&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 二级缓存的产品（需要xml文件） --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.cache.region.factory_class&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 查询缓存 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hibernate.cache.use_query_cache&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span>\t</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><shared-cache-mode>ENABLE_SELECTIVE</shared-cache-mode></p>\n</blockquote>\n<p><strong>ENABLE_SELECTIVE：标识 @Cacheable(true) 注解的实体类将被缓存</strong></p>\n<h3 id=\"JPA-JPQL-HelloWorld\">JPA_JPQL_HelloWorld</h3>\n<ul>\n<li>\n<p><strong>JPQL语言，即 Java Persistence Query Language 的简称</strong>。JPQL 是一种和 SQL 非常类似的中间性和对象化查询语言，它最终会被编译成针对不同底层数据库的 SQL 查询，从而屏蔽不同数据库的差异。</p>\n</li>\n<li>\n<p>JPQL语言的语句可以是 <strong>select 语句、update 语句或delete语句</strong>，它们都通过 Query 接口封装执行</p>\n</li>\n<li>\n<p><strong>Query接口</strong>封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、create NamedQuery 及 createNativeQuery 方法可以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作。</p>\n</li>\n</ul>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210625202745850.png\" alt=\"image-20210625202745850\"></p>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210625202823920.png\" alt=\"image-20210625202823920\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testHelloJPQL</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;FROM Customer c WHERE c.age &gt; ?&quot;</span>;</span><br><span class=\"line\">    Query query = entityManager.createQuery(jpql);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//占位符的索引是从 1 开始</span></span><br><span class=\"line\">    query.setParameter(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    List&lt;Customer&gt; customers = query.getResultList();</span><br><span class=\"line\">    System.out.println(customers.size());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认情况下, 若只查询部分属性, 则将返回 Object[] 类型的结果. 或者 Object[] 类型的 List.</span></span><br><span class=\"line\"><span class=\"comment\">//也可以在实体类中创建对应的构造器, 然后再 JPQL 语句中利用对应的构造器返回实体类的对象.</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPartlyProperties</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;SELECT new Customer(c.lastName, c.age) FROM Customer c WHERE c.id &gt; ?&quot;</span>;</span><br><span class=\"line\">    List result = entityManager.createQuery(jpql).setParameter(<span class=\"number\">1</span>, <span class=\"number\">1</span>).getResultList();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//createNamedQuery 适用于在实体类前使用 @NamedQuery 标记的查询语句</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testNamedQuery</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Query query = entityManager.createNamedQuery(<span class=\"string\">&quot;testNamedQuery&quot;</span>).setParameter(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    Customer customer = (Customer) query.getSingleResult();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(customer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//createNativeQuery 适用于本地 SQL</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testNativeQuery</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String sql = <span class=\"string\">&quot;SELECT age FROM jpa_cutomers WHERE id = ?&quot;</span>;</span><br><span class=\"line\">    Query query = entityManager.createNativeQuery(sql).setParameter(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Object result = query.getSingleResult();</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-JPQL-查询缓存\">JPA_JPQL_查询缓存</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认情况下是两条sql，使用 hibernate 的查询缓存可以只用一条sql. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testQueryCache</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;FROM Customer c WHERE c.age &gt; ?&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//使用查询缓存</span></span><br><span class=\"line\">    Query query = entityManager.createQuery(jpql).setHint(QueryHints.HINT_CACHEABLE, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//占位符的索引是从 1 开始</span></span><br><span class=\"line\">    query.setParameter(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    List&lt;Customer&gt; customers = query.getResultList();</span><br><span class=\"line\">    System.out.println(customers.size());</span><br><span class=\"line\"></span><br><span class=\"line\">    query = entityManager.createQuery(jpql).setHint(QueryHints.HINT_CACHEABLE, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//占位符的索引是从 1 开始</span></span><br><span class=\"line\">    query.setParameter(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    customers = query.getResultList();</span><br><span class=\"line\">    System.out.println(customers.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-JPQL-ORDERBY和GROUPBY\">JPA_JPQL_ORDERBY和GROUPBY</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOrderBy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;FROM Customer c WHERE c.age &gt; ? ORDER BY c.age DESC&quot;</span>;</span><br><span class=\"line\">    Query query = entityManager.createQuery(jpql).setHint(QueryHints.HINT_CACHEABLE, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//占位符的索引是从 1 开始</span></span><br><span class=\"line\">    query.setParameter(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    List&lt;Customer&gt; customers = query.getResultList();</span><br><span class=\"line\">    System.out.println(customers.size());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询 order 数量大于 2 的那些 Customer</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testGroupBy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;SELECT o.customer FROM Order o &quot;</span></span><br><span class=\"line\">        + <span class=\"string\">&quot;GROUP BY o.customer &quot;</span></span><br><span class=\"line\">        + <span class=\"string\">&quot;HAVING count(o.id) &gt;= 2&quot;</span>;</span><br><span class=\"line\">    List&lt;Customer&gt; customers = entityManager.createQuery(jpql).getResultList();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(customers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-JPQL-关联查询\">JPA_JPQL_关联查询</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * JPQL 的关联查询同 HQL 的关联查询. </span></span><br><span class=\"line\"><span class=\"comment\"> * fetch的作用是：使得查询结果返回的是一个Customer和Order组成的对象，而不是一个Object[]数组。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLeftOuterJoinFetch</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;FROM Customer c LEFT OUTER JOIN FETCH c.orders WHERE c.id = ?&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Customer customer = </span><br><span class=\"line\">        (Customer) entityManager.createQuery(jpql).setParameter(<span class=\"number\">1</span>, <span class=\"number\">12</span>).getSingleResult();</span><br><span class=\"line\">    System.out.println(customer.getLastName());</span><br><span class=\"line\">    System.out.println(customer.getOrders().size());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//\t\tList&lt;Object[]&gt; result = entityManager.createQuery(jpql).setParameter(1, 12).getResultList();</span></span><br><span class=\"line\">    <span class=\"comment\">//\t\tSystem.out.println(result);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPQL-子查询和内建函数\">JPQL_子查询和内建函数</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSubQuery</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//查询所有 Customer 的 lastName 为 YY 的 Order</span></span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;SELECT o FROM Order o &quot;</span></span><br><span class=\"line\">        + <span class=\"string\">&quot;WHERE o.customer = (SELECT c FROM Customer c WHERE c.lastName = ?)&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Query query = entityManager.createQuery(jpql).setParameter(<span class=\"number\">1</span>, <span class=\"string\">&quot;YY&quot;</span>);</span><br><span class=\"line\">    List&lt;Order&gt; orders = query.getResultList();</span><br><span class=\"line\">    System.out.println(orders.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testJpqlFunction</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;SELECT lower(c.email) FROM Customer c&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;String&gt; emails = entityManager.createQuery(jpql).getResultList();</span><br><span class=\"line\">    System.out.println(emails);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-JPQL-DELETE和UPDATE\">JPA_JPQL_DELETE和UPDATE</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以使用 JPQL 完成 UPDATE 和 DELETE 操作. </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testExecuteUpdate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    String jpql = <span class=\"string\">&quot;UPDATE Customer c SET c.lastName = ? WHERE c.id = ?&quot;</span>;</span><br><span class=\"line\">    Query query = entityManager.createQuery(jpql).setParameter(<span class=\"number\">1</span>, <span class=\"string\">&quot;YYY&quot;</span>).setParameter(<span class=\"number\">2</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    query.executeUpdate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JPA-整合Spring\">JPA_整合Spring</h3>\n<ul>\n<li>三种整合方式\n<ul>\n<li>LocalEntityManagerFactoryBean：适用于那些仅使用 JPA 进行数据访问的项目，该 FactoryBean 将根据JPA PersistenceProvider 自动检测配置文件进行工作，一般从“META-INF/persistence.xml”读取配置信息，这种方式最简单，<strong>但不能设置 Spring 中定义的DataSource，且不支持 Spring 管理的全局事务</strong></li>\n<li>从JNDI中获取：<strong>用于从 Java EE 服务器获取指定的EntityManagerFactory</strong>，这种方式在进行 Spring 事务管理时一般要使用 JTA 事务管理</li>\n<li><strong>LocalContainerEntityManagerFactoryBean</strong>(建议使用)：适用于所有环境的 FactoryBean，能全面控制 EntityManagerFactory 配置,如指定 Spring 定义的 DataSource 等等。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Spring-Data\">Spring Data</h2>\n<h3 id=\"概述\">概述</h3>\n<ul>\n<li>Spring 的一个子项目。用于简化数据库访问，<strong>支持NoSQL 和 关系数据存储</strong>。其【主要目标】是使【数据库的访问变得方便快捷】。</li>\n<li>JPA Spring Data 概述\n<ul>\n<li>致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！</li>\n<li>框架怎么可能代替开发者实现业务逻辑呢？比如：当有一个 UserDao.findUserById()  这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User  对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HelloWorld-2\">HelloWorld</h3>\n<ul>\n<li>使用 Spring Data JPA 进行持久层开发需要的四个步骤：\n<ul>\n<li><strong>配置 Spring 整合 JPA</strong></li>\n<li>**在 Spring 配置文件中配置 Spring Data，让 Spring 为声明的接口创建代理对象。**配置了 <a href=\"jpa:repositories\">jpa:repositories</a> 后，Spring 初始化容器时将会扫描 base-package  指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring 自动封装的特性来直接使用该对象。</li>\n<li><strong>声明持久层的接口</strong>，该接口继承  Repository，Repository 是一个标记型接口，它不包含任何方法，如必要，Spring Data 可实现 Repository 其他子接口，其中定义了一些常用的增删改查，以及分页相关的方法。</li>\n<li><strong>在接口中声明需要的方法</strong>。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。</li>\n</ul>\n</li>\n</ul>\n<p>applicationContext.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 1. 配置c3p0数据源 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.user&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClass&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;jdbcUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;jdbc.jdbcUrl&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置其他属性 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2. 配置 JPA 的 EntityManagerFactory --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;entityManagerFactory&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;jpaVendorAdapter&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 对应@Entity注解 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;packagesToScan&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.atguigu.springdata&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;jpaProperties&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 二级缓存相关 --&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--  </span></span><br><span class=\"line\"><span class=\"comment\">    &lt;prop key=&quot;hibernate.cache.region.factory_class&quot;&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/prop&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;prop key=&quot;net.sf.ehcache.configurationResourceName&quot;&gt;ehcache-hibernate.xml&lt;/prop&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 生成的数据表的列的映射策略 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.ejb.naming_strategy&quot;</span>&gt;</span>org.hibernate.cfg.ImprovedNamingStrategy<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- hibernate 基本属性 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL5InnoDBDialect<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 3. 配置事务管理器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;entityManagerFactory&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;entityManagerFactory&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 4. 配置支持注解的事务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 5. 配置 SpringData --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 加入  jpa 的命名空间 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- base-package: 扫描 Repository Bean 所在的 package --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jpa:repositories</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.atguigu.springdata&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                  <span class=\"attr\">entity-manager-factory-ref</span>=<span class=\"string\">&quot;entityManagerFactory&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jpa:repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">jdbc.user</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"meta\">jdbc.password</span>=<span class=\"string\">1230</span></span><br><span class=\"line\"><span class=\"meta\">jdbc.driverClass</span>=<span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"meta\">jdbc.jdbcUrl</span>=<span class=\"string\">jdbc:mysql:///jpa</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"代码测试\">代码测试</h4>\n<p>实体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Table(name=&quot;JPA_PERSONS&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String lastName;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String email;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Date birth;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Address address;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer addressId;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@GeneratedValue</span></span><br><span class=\"line\">\t<span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> lastName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLastName</span><span class=\"params\">(String lastName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.lastName = lastName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> email;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(String email)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">getBirth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> birth;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBirth</span><span class=\"params\">(Date birth)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.birth = birth;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Column(name=&quot;ADD_ID&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAddressId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> addressId;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAddressId</span><span class=\"params\">(Integer addressId)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.addressId = addressId;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@JoinColumn(name=&quot;ADDRESS_ID&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@ManyToOne</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Address <span class=\"title\">getAddress</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> address;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAddress</span><span class=\"params\">(Address address)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.address = address;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Person [id=&quot;</span> + id + <span class=\"string\">&quot;, lastName=&quot;</span> + lastName + <span class=\"string\">&quot;, email=&quot;</span></span><br><span class=\"line\">\t\t\t\t+ email + <span class=\"string\">&quot;, brith=&quot;</span> + birth + <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>变量初始化（整个课程的测试代码都可以使用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ApplicationContext ctx = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> PersonRepsotory personRepsotory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> PersonService personService;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    personRepsotory = ctx.getBean(PersonRepsotory.class);</span><br><span class=\"line\">    personService = ctx.getBean(PersonService.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试数据源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testDataSource</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    DataSource dataSource = ctx.getBean(DataSource.class);</span><br><span class=\"line\">    System.out.println(dataSource.getConnection());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试JPA的是否配置成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先创建一个实体类，再执行这个代码</span></span><br><span class=\"line\"><span class=\"comment\">//执行，应该在数据库中成功建表</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testJpa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试helloworld（包含Spring Data）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepsotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据 lastName 来获取对应的 Person</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">getByLastName</span><span class=\"params\">(String lastName)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testHelloWorldSpringData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> FileNotFoundException, IOException, InstantiationException, IllegalAccessException</span>&#123;</span><br><span class=\"line\">    System.out.println(personRepsotory.getClass().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    Person person = personRepsotory.getByLastName(<span class=\"string\">&quot;AA&quot;</span>);</span><br><span class=\"line\">    System.out.println(person);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Repository接口\">Repository接口</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. Repository 是一个空接口. 即是一个标记接口</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 若我们定义的接口继承了 Repository, 则该接口会被 IOC 容器识别为一个 Repository Bean.</span></span><br><span class=\"line\"><span class=\"comment\"> * 纳入到 IOC 容器中. 进而可以在该接口中定义满足一定规范的方法. </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 3. 实际上, 也可以通过 <span class=\"doctag\">@RepositoryDefinition</span> 注解来替代继承 Repository 接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//@RepositoryDefinition(domainClass=Person.class,idClass=Integer.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepsotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">Repository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据 lastName 来获取对应的 Person</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">getByLastName</span><span class=\"params\">(String lastName)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Repository查询方法定义规范\">Repository查询方法定义规范</h3>\n<ul>\n<li>简单条件查询: 查询某一个实体类或者集合</li>\n<li>按照 Spring Data 的规范，查询方法以 find | read | get 开头， 涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写。</li>\n<li>支持属性的级联查询. <strong>若当前类有符合条件的属性, 则优先使用, 而不使用级联属性。<strong>若需要使用级联属性, 则</strong>属性之间使用 _ 进行连接.</strong></li>\n<li>支持的关键字</li>\n</ul>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210626131551793.png\" alt=\"image-20210626131551793\"></p>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210626131616402.png\" alt=\"image-20210626131616402\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//WHERE lastName LIKE ?% AND id &lt; ?</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">getByLastNameStartingWithAndIdLessThan</span><span class=\"params\">(String lastName, Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WHERE lastName LIKE %? AND id &lt; ?</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">getByLastNameEndingWithAndIdLessThan</span><span class=\"params\">(String lastName, Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WHERE email IN (?, ?, ?) OR birth &lt; ?</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">getByEmailInAndBirthLessThan</span><span class=\"params\">(List&lt;String&gt; emails, Date birth)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//WHERE a.id &gt; ?</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">getByAddress_IdGreaterThan</span><span class=\"params\">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Query注解\">Query注解</h3>\n<ul>\n<li>这种查询可以声明在 Repository 方法中，<strong>摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明</strong>，结构更为清晰，这是 Spring data 的特有实现。</li>\n<li>可以实现更复杂的查询，比如子查询</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询 id 值最大的那个 Person</span></span><br><span class=\"line\"><span class=\"comment\">//使用 @Query 注解可以自定义 JPQL 语句以实现更灵活的查询</span></span><br><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT p FROM Person p WHERE p.id = (SELECT max(p2.id) FROM Person p2)&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">getMaxIdPerson</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//为 @Query 注解传递参数的方式1: 使用占位符. </span></span><br><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT p FROM Person p WHERE p.lastName = ?1 AND p.email = ?2&quot;)</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">testQueryAnnotationParams1</span><span class=\"params\">(String lastName, String email)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//为 @Query 注解传递参数的方式1: 命名参数的方式. </span></span><br><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT p FROM Person p WHERE p.lastName = :lastName AND p.email = :email&quot;)</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">testQueryAnnotationParams2</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;email&quot;)</span> String email, <span class=\"meta\">@Param(&quot;lastName&quot;)</span> String lastName)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SpringData 允许在占位符上添加 %%. </span></span><br><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT p FROM Person p WHERE p.lastName LIKE %?1% OR p.email LIKE %?2%&quot;)</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">testQueryAnnotationLikeParam</span><span class=\"params\">(String lastName, String email)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SpringData 允许在占位符上添加 %%. </span></span><br><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT p FROM Person p WHERE p.lastName LIKE %:lastName% OR p.email LIKE %:email%&quot;)</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Person&gt; <span class=\"title\">testQueryAnnotationLikeParam2</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;email&quot;)</span> String email, <span class=\"meta\">@Param(&quot;lastName&quot;)</span> String lastName)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置 nativeQuery=true 即可以使用原生的 SQL 查询</span></span><br><span class=\"line\"><span class=\"meta\">@Query(value=&quot;SELECT count(id) FROM jpa_persons&quot;, nativeQuery=true)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getTotalCount</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Modifying注解\">Modifying注解</h3>\n<ul>\n<li>@Query 与 @Modifying 这两个 annotation一起声明，可定义个性化更新操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以通过自定义的 JPQL 完成 UPDATE 和 DELETE 操作. 注意: JPQL 不支持使用 INSERT</span></span><br><span class=\"line\"><span class=\"comment\">//在 @Query 注解中编写 JPQL 语句, 但必须使用 @Modifying 进行修饰. 以通知 SpringData, 这是一个 UPDATE 或 DELETE 操作</span></span><br><span class=\"line\"><span class=\"comment\">//UPDATE 或 DELETE 操作需要使用事务, 此时需要定义 Service 层. 在 Service 层的方法上添加事务操作. </span></span><br><span class=\"line\"><span class=\"comment\">//默认情况下, SpringData 的每个方法上有事务, 但都是一个只读事务. 他们不能完成修改操作!</span></span><br><span class=\"line\"><span class=\"meta\">@Modifying</span></span><br><span class=\"line\"><span class=\"meta\">@Query(&quot;UPDATE Person p SET p.email = :email WHERE id = :id&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updatePersonEmail</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;id&quot;)</span> Integer id, <span class=\"meta\">@Param(&quot;email&quot;)</span> String email)</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> PersonRepsotory personRepsotory;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updatePersonEmail</span><span class=\"params\">(String email, Integer id)</span></span>&#123;</span><br><span class=\"line\">\t\tpersonRepsotory.updatePersonEmail(id, email);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testModifying</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//\t\tpersonRepsotory.updatePersonEmail(1, &quot;mmmm@atguigu.com&quot;);</span></span><br><span class=\"line\">    personService.updatePersonEmail(<span class=\"string\">&quot;mmmm@atguigu.com&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CrudRepository接口\">CrudRepository接口</h3>\n<ul>\n<li>CrudRepository 接口提供了最基本的对实体类的添删改查操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepsotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> PersonRepsotory personRepsotory;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">savePersons</span><span class=\"params\">(List&lt;Person&gt; persons)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//CrudRepository 接口的save(Iterable&lt;T&gt;)方法</span></span><br><span class=\"line\">\t\tpersonRepsotory.save(persons);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCrudReposiory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"string\">&#x27;a&#x27;</span>; i &lt;= <span class=\"string\">&#x27;z&#x27;</span>; i++)&#123;</span><br><span class=\"line\">        Person person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">        person.setAddressId(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        person.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        person.setEmail((<span class=\"keyword\">char</span>)i + <span class=\"string\">&quot;&quot;</span> + (<span class=\"keyword\">char</span>)i + <span class=\"string\">&quot;@atguigu.com&quot;</span>);</span><br><span class=\"line\">        person.setLastName((<span class=\"keyword\">char</span>)i + <span class=\"string\">&quot;&quot;</span> + (<span class=\"keyword\">char</span>)i);</span><br><span class=\"line\"></span><br><span class=\"line\">        persons.add(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    personService.savePersons(persons);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"PagingAndSortingRespository接口\">PagingAndSortingRespository接口</h3>\n<ul>\n<li>该接口提供了分页与排序功能\n<ul>\n<li>Iterable<T> findAll(Sort sort); //排序</li>\n<li><strong>Page<T> findAll(Pageable pageable)</strong>; //分页查询（含排序功能）</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepsotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">PagingAndSortingRespository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPagingAndSortingRespository</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//pageNo 从 0 开始. </span></span><br><span class=\"line\">    <span class=\"comment\">//第三页</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pageNo = <span class=\"number\">3</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pageSize = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"comment\">//Pageable 接口通常使用的其 PageRequest 实现类. 其中封装了需要分页的信息</span></span><br><span class=\"line\">    <span class=\"comment\">//排序相关的. Sort 封装了排序的信息</span></span><br><span class=\"line\">    <span class=\"comment\">//Order 是具体针对于某一个属性进行升序还是降序. </span></span><br><span class=\"line\">    Order order1 = <span class=\"keyword\">new</span> Order(Direction.DESC, <span class=\"string\">&quot;id&quot;</span>);</span><br><span class=\"line\">    Order order2 = <span class=\"keyword\">new</span> Order(Direction.ASC, <span class=\"string\">&quot;email&quot;</span>);</span><br><span class=\"line\">    Sort sort = <span class=\"keyword\">new</span> Sort(order1, order2);</span><br><span class=\"line\"></span><br><span class=\"line\">    PageRequest pageable = <span class=\"keyword\">new</span> PageRequest(pageNo, pageSize, sort);</span><br><span class=\"line\">    Page&lt;Person&gt; page = personRepsotory.findAll(pageable);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;总记录数: &quot;</span> + page.getTotalElements());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;当前第几页: &quot;</span> + (page.getNumber() + <span class=\"number\">1</span>));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;总页数: &quot;</span> + page.getTotalPages());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;当前页面的 List: &quot;</span> + page.getContent());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;当前页面的记录数: &quot;</span> + page.getNumberOfElements());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210626135311053.png\" alt=\"image-20210626135311053\"></p>\n<p>注：当前在第三页</p>\n<h3 id=\"JpaRepository接口\">JpaRepository接口</h3>\n<ul>\n<li>该接口提供了JPA的相关功能</li>\n</ul>\n<p>测试该接口的T saveAndFlush(T entity)方法。该方法相当于jpa的merge方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepsotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testJpaRepository</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Person person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    person.setBirth(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">    person.setEmail(<span class=\"string\">&quot;xy@atguigu.com&quot;</span>);</span><br><span class=\"line\">    person.setLastName(<span class=\"string\">&quot;xyz&quot;</span>);</span><br><span class=\"line\">    person.setId(<span class=\"number\">28</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//返回一个代理对象</span></span><br><span class=\"line\">    Person person2 = personRepsotory.saveAndFlush(person);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(person == person2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JpaSpecificationExecutor接口\">JpaSpecificationExecutor接口</h3>\n<ul>\n<li>不属于Repository体系，实现一组 JPA Criteria 查询相关的方法</li>\n<li>Specification：封装  JPA Criteria 查询条件。通常使用匿名内部类的方式来创建该接口的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepsotory</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Integer</span>&gt;,<span class=\"title\">JpaSpecificationExecutor</span>&lt;<span class=\"title\">Person</span>&gt;</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>实现带查询条件的分页</strong>(PagingAndSortingRespository接口做不到)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 目标: 实现带查询条件的分页. id &gt; 5 的条件</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* 调用 JpaSpecificationExecutor 的 Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable);</span></span><br><span class=\"line\"><span class=\"comment\">* Specification: 封装了 JPA Criteria 查询的查询条件</span></span><br><span class=\"line\"><span class=\"comment\">* Pageable: 封装了请求分页的信息: 例如 pageNo, pageSize, Sort</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testJpaSpecificationExecutor</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pageNo = <span class=\"number\">3</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pageSize = <span class=\"number\">5</span>;</span><br><span class=\"line\">    PageRequest pageable = <span class=\"keyword\">new</span> PageRequest(pageNo, pageSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通常使用 Specification 的匿名内部类</span></span><br><span class=\"line\">    Specification&lt;Person&gt; specification = <span class=\"keyword\">new</span> Specification&lt;Person&gt;() &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * <span class=\"doctag\">@param</span> *root: 代表查询的实体类. </span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * <span class=\"doctag\">@param</span> query: 可以从中可到 Root 对象, 即告知 JPA Criteria 查询要查询哪一个实体类. 还可以</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 来添加查询条件, 还可以结合 EntityManager 对象得到最终查询的 TypedQuery 对象. </span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * <span class=\"doctag\">@param</span> *cb: CriteriaBuilder 对象. 用于创建 Criteria 相关对象的工厂. 当然可以从中获取到 Predicate 对象</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * <span class=\"doctag\">@return</span>: *Predicate 类型, 代表一个查询条件. </span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Predicate <span class=\"title\">toPredicate</span><span class=\"params\">(Root&lt;Person&gt; root,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                     CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123;</span><br><span class=\"line\">            Path path = root.get(<span class=\"string\">&quot;id&quot;</span>);</span><br><span class=\"line\">            Predicate predicate = cb.gt(path, <span class=\"number\">5</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> predicate;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Page&lt;Person&gt; page = personRepsotory.findAll(specification, pageable);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;总记录数: &quot;</span> + page.getTotalElements());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;当前第几页: &quot;</span> + (page.getNumber() + <span class=\"number\">1</span>));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;总页数: &quot;</span> + page.getTotalPages());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;当前页面的 List: &quot;</span> + page.getContent());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;当前页面的记录数: &quot;</span> + page.getNumberOfElements());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Path path = root.get(“id”);</p>\n</blockquote>\n<p>上面这句代码参考下图理解：</p>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210626140727153.png\" alt=\"image-20210626140727153\"></p>\n<h3 id=\"自定义Repository方法\">自定义Repository方法</h3>\n<ul>\n<li>为某一个 Repository 上添加自定义方法\n<ul>\n<li>定义一个接口: 声明要添加的, 并自实现的方法</li>\n<li>提供该接口的实现类: 类名需在要声明的 Repository 后添加 Impl, 并实现方法</li>\n<li>声明 Repository 接口, 并继承 1) 声明的接口</li>\n<li>使用.</li>\n<li>注意: 默认情况下, Spring Data 会在 base-package 中查找 “接口名Impl” 作为实现类. 也可以通过　repository-impl-postfix　声明后缀.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"JPA-Spring-Data%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86.assets/image-20210626141302329.png\" alt=\"image-20210626141302329\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonDao</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonRepsotoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">PersonDao</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@PersistenceContext</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> EntityManager entityManager;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tPerson person = entityManager.find(Person.class, <span class=\"number\">11</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;--&gt;&quot;</span> + person);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonRepsotory</span> <span class=\"keyword\">extends</span> </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Person</span>, <span class=\"title\">Integer</span>&gt;,</span></span><br><span class=\"line\"><span class=\"class\">\t<span class=\"title\">JpaSpecificationExecutor</span>&lt;<span class=\"title\">Person</span>&gt;, <span class=\"title\">PersonDao</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCustomRepositoryMethod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    personRepsotory.test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"url":"/2021/07/18/Test%20basis/","content":"<h2 id=\"软件测试基本概念\">软件测试基本概念</h2>\n<ul>\n<li>\n<p>软件 = 程序+文档，软件测试 = 程序测试+文档测试<br><br>\n<strong>程序</strong>是指能够实现某种功能的指令集合，<strong>文档</strong>是指软件开发、使用和维护过程中产生的图文集合。</p>\n</li>\n<li>\n<p>软件的分类<br><br>\n按<strong>功能</strong>分：系统软件，应用软件。<br><br>\n按<strong>技术架构</strong>分：单机版软件，C/S结构软件（C指客户端，S指服务器端），B/S结构软件（B指浏览器）<br><br>\n按<strong>用户</strong>划分：产品软件，项目软件。<br><br>\n按<strong>开发规模</strong>划分：小型，中型，大型。<br></p>\n</li>\n<li>\n<p>BUG的定义<br><br>\n软件的BUG指的是软件中（包括程序和文档）<em>不符合用户需求</em>的问题。<br><br>\n常见的BUG分三种类型：<strong>完全</strong>没有实现功能；<strong>基本实现</strong>了用户需求的功能；实现了用户<strong>不需要的</strong>功能。<br></p>\n</li>\n<li>\n<p>软件测试的环境 = 软件+网络+硬件+数据准备+测试工具。<br><br>\n<strong>软件测试的环境要与软件生产运行环境保持一致，要从开发环境独立出来。</strong></p>\n</li>\n<li>\n<p>搭建环境：<strong>真实、干净、无毒、独立。</strong></p>\n</li>\n<li>\n<p>软件环境的分类<br><br>\n1.软件开发环境:软件在开发过程中使用的环境。<br><br>\n2.软件生产运行环境:最终用户使用的环境。</p>\n</li>\n<li>\n<p>测试用例：指在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据与其结果。<br><br>\n<strong>测试用例=输入+输出+测试环境</strong>（输入包括测试数据和操作步骤，输出指的是期望结果，测试环境指的是系统环境设置）。 测试用例有两个模板：word和excel，前者适合性能测试，后者适合功能测试。</p>\n</li>\n</ul>\n<h3 id=\"软件测试分类\">软件测试分类</h3>\n<ul>\n<li>\n<p><strong>黑盒测试</strong>：指的是把被测试的软件看做是一个黑盒子，我们不关心里面的结构是什么样的，只关心软件输入数据和输出结果。<br><br>\n黑盒测试技术：等价类划分、边界值、因果图、流程图。<br><br>\n<strong>白盒测试</strong>：指的是把盒子盖打开，去研究里面的源代码和程序结构。</p>\n</li>\n<li>\n<p><strong>静态测试</strong>：是指不实际运行被测软件，而只是静态的检查程序代码、界面或文档中可能存在的错误的过程。<br><br>\n<strong>动态测试</strong>：是指实际运行被测程序，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程。<br><br>\n我们判断一个测试属于动态测试还是静态测试的唯一标准就是看是否运行程序。<br></p>\n</li>\n</ul>\n<blockquote>\n<p><em><strong>注意</strong></em>：同一个测试既有可能属于黑盒测试，也有可能属于动态测试；既有可能属于静态测试，也有可能属于白盒测试。它们之间也有可能交叉。</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>按过程分类</strong></p>\n<ol>\n<li>\n<p><strong>单元测试</strong>：指的是对软件中最小可测试单元进行检查和验证。<br></p>\n</li>\n<li>\n<p><strong>集成测试</strong>：是单元测试的下一个阶段，是指将通过测试的单元模块组成系统或子系统，再进行测试，重点测试不同模块的接口部分。<br></p>\n</li>\n<li>\n<p><strong>系统测试</strong>：指的是将整个软件系统看作1个整体进行测试，包括功能、性能，以及软件所有运行的硬件环境进行测试。</p>\n</li>\n<li>\n<p><strong>验收测试</strong>：指的是在系统测试的后期，以用户测试为主，或有测试人员等质量保障人员共同参与的测试它也是软件正式交付给用户使用的最后一道工序。<br><br>\n验收测试又分为α测试和β测试，α测试指的是由用户、测试人员、开发人员等共同参与的内部测试；β测试指的是内测后的公测，即完全交给最终的用户测试。</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>功能测试</strong>：是黑盒测试的一方面，它检测实际软件的功能是否符合用户的需求。功能测试又能细分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等。</p>\n</li>\n<li>\n<p><strong>性能测试</strong>：软件的性能包括很多方面，主要有时间性能和空间性能两种。<br></p>\n<ol>\n<li>时间性能：主要指软件的一个具体事务的响应时间。</li>\n<li>空间性能：主要指软件运行时所消耗的系统资源。<br></li>\n</ol>\n<p>软件性能测试一般分为一般性能测试、稳定性能测试、负载测试和压力测试。<br></p>\n<ol>\n<li>\n<p><strong>一般性能测试</strong>：让系统在正常的软硬件环境下运行，不向其施加任何压力的性能测试。<br></p>\n</li>\n<li>\n<p><strong>稳定性能测试</strong>（又称可靠性测试）：连续运行内测系统，检查系统运行的时间稳定程度。通常用MTBF（错误发生的平均时间间隔）来衡量系统的稳定性，越大稳定性越强。<br></p>\n</li>\n<li>\n<p><strong>负载测试</strong>：让被测系统在其能忍受的极限范围之内连续运行，来测试系统的稳定性。<br></p>\n</li>\n<li>\n<p><strong>压力测试</strong>：连续不断的给被测系统增加压力，直到被测系统压垮为止，用来测试系统所能承受的最大压力。<br><br>\n关于性能测试，可以用一个通俗的例子来理解：</p>\n</li>\n</ol>\n<p>假设一个人很轻松就能背一袋米，背两袋米很吃力，最多就能背三袋米，那么<br></p>\n<pre><code>  一般性能测试————我就让他背一袋米。\n \n  稳定性测试—————我让他背一袋米，让他去操场上跑圈，看多久累倒。\n \n  负载测试————让他背两袋米去操场去跑圈，看多久累倒。\n \n  压力测试————让他背两袋米，三袋米，四袋米·····发现他最多只能背三袋米。\n</code></pre>\n</li>\n<li>\n<p><strong>回归测试</strong>：是指对软件的新的版本测试时，重复执行上一个版本测试时的用例</p>\n</li>\n<li>\n<p><strong>冒烟测试</strong>：指对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否可以实现，是否具备可测性。</p>\n</li>\n<li>\n<p><strong>随机测试</strong>（又称猴子测试）：指测试中所有的输入数据都是随机生产的，其<strong>目的</strong>是模拟用户的真实操作，并发现边缘错误。<br><br>\n随机测试的缺点：测试不系统，无法统计代码覆盖率和需求覆盖率，很难回归测试等。</p>\n</li>\n<li>\n<p>不同测试分类之间的关系<br><br>\n<img src=\"../image/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.png\" alt=\"分类图片\"></p>\n</li>\n<li>\n<p>什么是SQA？<br><br>\nSQA(Software Quality Assurance,软件质量保障)的完整定义为：为确保软件开发过程和结果符合预期要求而建立的一系列规程，以及依照规程和计划采取的一系列活动及其结果评价。</p>\n</li>\n<li>\n<p>软件测试的一些基本原则</p>\n<ul>\n<li>\n<p>zero bug 和 good enough<br><br>\nzero bug指的是软件没有任何的bug，good enough指的是只要软件达到一定的质量要求，就可以停止测试了。<br><br>\ngood enough原则是一种权衡投入/产出比的原则：不充分的测试是不负责任的；过分的测试是一种资源的浪费，同样也是不负责任的表现。</p>\n</li>\n<li>\n<p>不要试图穷举测试<br><br>\n穷举测试指的是测试时，考虑所有的可能的输入值。这是不切实际的，我们不可能把所有的输入值都考虑到并且这很花费时间和资源。我们需要使用最少的测试用例，来达到最大的覆盖率。</p>\n</li>\n<li>\n<p>软件测试要尽早执行<br><br>\n在需求分析阶段，引入的缺陷是最多的，修复成本是最少低的。所以要尽早开始软件测试，越到后面，修复成本越高。</p>\n</li>\n<li>\n<p>软件测试应该追溯需求<br><br>\n软件缺陷产生的原因（如图）<br>\n<img src=\"../image/%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0.png\" alt=\"软件缺陷产生的原因\"></p>\n</li>\n<li>\n<p>缺陷的<strong>二八原则</strong><br><br>\n二八原则指的是一般情况下，软件80%的缺陷集中在20%的模块中。所以我们测试时，在这20%的模块上，要投入较多的人力和精力重点测试。</p>\n</li>\n<li>\n<p>缺陷具有免疫力<br><br>\n如同害虫会对农药产生抗药性一样，缺陷也会产生&quot;抗药性&quot;。用旧版本的测试用例去测新版本的软件时，效果会大大的折扣。这就要求我们需要根据新版本的特点去修改和维护测试用。<br></p>\n<blockquote>\n<p><strong>注意</strong>：每修复三到四个缺陷，一般就会产生一个新的缺陷。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>软件测试模型</p>\n<ul>\n<li>\n<p>瀑布模型<br></p>\n</li>\n<li>\n<p>V模型<br><br>\n<img src=\"../image/v%E6%A8%A1%E5%9E%8B.png\" alt=\"v模型\"></p>\n</li>\n<li>\n<p>W模型<br><br>\n<img src=\"../image/w%E6%A8%A1%E5%9E%8B.png\" alt=\"w模型\"></p>\n</li>\n<li>\n<p>H模型<br><br>\n<img src=\"../image/h%E6%A8%A1%E5%9E%8B.png\" alt=\"h模型\"></p>\n</li>\n<li>\n<p>x模型<br><br>\n<img src=\"../image/x%E6%A8%A1%E5%9E%8B.png\" alt=\"x模型\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>黑盒测试技术</p>\n<ul>\n<li>\n<p><strong>等价类划分</strong><br><br>\n等价类划分可分为有效等价类和无效等价类。<br></p>\n<blockquote>\n<p>有效等价类：指符合《需求规格说明书》，合理地输入数据集合。<br><br>\n无效等价类：指不符合《需求规格说明书》，无意义地输入数据集合。</p>\n</blockquote>\n<ul>\n<li>\n<p>等价类栗子：</p>\n<p>假设登录用户名只能是字母和数字，这时字母和数字就是有效等价类，非字母和数字都是无效等价类。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>边界值划分</strong><br><br>\n边界值指输入和输出等价类中那些恰好处于边界、或者超过边界、或者在边界一下的状态的值。</p>\n<blockquote>\n<p>边界值分析和等价类划分方法存在两方面不同：<br><br>\n1. 与从等价类中挑选出任意一个元素作为代表不同，边界值分析需要选择一个或多个元素，以便等价类的每个边界都经过一次测试。<br><br>\n2. 与仅仅关注输入条件（输入空间）不同，还需要考虑从结果空间（输出等价类）设计测试用例。</p>\n</blockquote>\n<ul>\n<li>边界值栗子：<br><br>\n假设输入域输入值范围为1~10，那么0、11就是离点，1、10就是上点，2,9就是内点。</li>\n</ul>\n</li>\n<li>\n<p><strong>决策表</strong><br><br>\n决策表也被成为判定表，适合描述在不同逻辑条件下取值组合的情况下需要执行的动作。</p>\n<blockquote>\n<p>决策表由四个部分组成：<br><br>\n决策桩：列出问题中可能出现的条件。<br><br>\n动作桩：列出解决问题可能采取的操作。<br><br>\n条件项：针对所有条件的取值列出不同条件取值的组合。<br><br>\n动作项：在条件项各种取值的情况下应该采取的动作。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>因果图法</strong><br><br>\n因指的是输入；果指的是输出。因果图法比较适合输入条件比较多的情况。<br><br>\n因果图有助于用一个系统的方法选择出高效的测试用例集。它还有一个额外的好处，就是可以指出规格说明的不完整性和不明确性。</p>\n<ul>\n<li>因果图栗子：<br>\npass</li>\n</ul>\n</li>\n<li>\n<p><strong>流程图法</strong><br><br>\n算法流程图是针对程序内部结构的，而黑盒测试的流程图是针对整个系统业务功能流程的。<br><br>\n流程图法一般不是针对某个页面或是某个模块的测试，而是将被测系统看作一个完整的系统，从宏观上来分析其业务流程，然后再画出流程图。</p>\n<ul>\n<li>流程图栗子：<br>\npass</li>\n</ul>\n</li>\n<li>\n<p><strong>场景法</strong><br><br>\n根据实际情况，对程序的功能或业务进行描述，模拟特定情况下，可能发生的事件，观察事件的最终结果。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>代码检查、走查与审评（本内容摘抄于《软件测试的艺术》）</p>\n<ul>\n<li>代码检查与走查<br><br>\n代码检查、走查以及可用性测试是三种主要的人工测试方法。<br><br>\n所谓<strong>代码检查</strong>，是以组为单位阅读代码，它是一系列规程和错误检查技术的集合。<br><br>\n<strong>代码走查</strong>与代码检查很相似，但是规程稍微有所不同，采用的错误检查技术也不一样。<br><br>\n代码检查、走查都要求人们组成一个小组来阅读或直观检查特定的程序。<br><br>\n代码走查的优点：一旦发现错误，通常就能在代码中对其进行精确定位，降低了调试（错误修正）的成本。这个过程通常发现成批的错误，这样的错误就可以一同得到修正。</li>\n</ul>\n<blockquote>\n<p>代码检查的衍生功效：其一，程序员通常会得到编程风格、算法选择及编程技术等方面的反馈信息。<br>\n其二，其他参与者也可以通过接触程序员的错误和编程风格而同样受益匪浅。<br>\n其三，能够在早期发现程序中脆弱部分的方法之一，有助于在测试过程中将更多的注意力集中在这些脆弱的地方。</p>\n</blockquote>\n<ul>\n<li>用于代码检查的错误列表\n<ol>\n<li>数据引用错误</li>\n<li>数据声明错误</li>\n<li>运算错误</li>\n<li>比较错误</li>\n<li>流程控制错误</li>\n<li>控制流错误</li>\n<li>接口错误</li>\n<li>输入/输出错误</li>\n<li>其他错误</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>白盒测试方法</p>\n<ul>\n<li>\n<p>语句覆盖：<br>\n设计若干个测试用例，使得被测程序的每一条可执行语句至少被执行一次。</p>\n</li>\n<li>\n<p>判定覆盖（分支覆盖）：<br>\n设计若干个测试用例，使得被测程序的每个判定语句至少有一次为真值，有一次为假值。</p>\n</li>\n<li>\n<p>条件覆盖：<br>\n设计若干个测试用例，使得被测程序的每个判定语句中的每个条件的可能结果至少执行一次。</p>\n</li>\n<li>\n<p>判定/条件覆盖：<br>\n设计若干个测试用例，使得被测程序的每个判定语句中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。</p>\n</li>\n<li>\n<p>条件组合覆盖：<br>\n设计若干个测试用例，使得被测程序的每个判定语句中的每个条件的可能结果的所有组合至少执行一次。</p>\n</li>\n<li>\n<p>路径覆盖：<br>\n设计若干个测试用例，使得被测程序中的所有路径执行一次。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"软件失效分类\">软件失效分类</h3>\n<p>软件失效机制可以描述为：软件错误-&gt;软件缺陷-&gt;软件故障-&gt;软件失效</p>\n<ul>\n<li>软件错误是指在软件生存期内的不希望或不可接受的人为错误，其结果是导致软件缺陷的产生。可<br>\n见，软件错误是一种人为过程，相对于软件本身，是一种外部行为。</li>\n<li>软件缺陷存在于软件（文档、数据、程序）之中的那些不希望或不可接受的偏差。其结果是软件运<br>\n行于某一特定条件时出现软件故障，这时称软件缺陷阶段。</li>\n<li>软件故障是指软件运行过程中出现的一种不希望或不可接受的内部状态。</li>\n<li>软件失效是指软件运行时产生的一种不希望或不可接受的外部行为结果。</li>\n</ul>\n<p>错误的定义是：不正确的事务和行为。错误是在系统运行时，引起或可能潜在地引起失效的缺陷，是一种面向开发概念。</p>\n<p>软件缺陷：</p>\n<ul>\n<li>软件未达到产品说明书中标明的功能；</li>\n<li>软件出现了产品说明书中指明的不会出现的错误；</li>\n<li>软件功能超出了产品说明书指明的范围；</li>\n<li>软件未达到产品说明书虽未指出应达到的目标；</li>\n<li>软件测试人员认为软件难以理解、不易使用、运行速度慢，或最终用户认为不好使用。</li>\n</ul>\n<p>产品说明书是软件缺陷的第一来源，也就出自于软件需求说明书本身的问题。</p>\n<p>设计方案（软件设计说明书）是软件缺陷第二来源。</p>\n<h4 id=\"缺陷与错误严重性和优先级\">缺陷与错误严重性和优先级</h4>\n<p>软件缺陷和错误会带来软件失效的风险，重要软件故障与失效会导致重大的经济损失与灾难。给软件缺陷与错误划分严重性和优先级的通用原则是：</p>\n<ul>\n<li>表示软件缺陷所造成的危害的恶劣程度；</li>\n<li>优先级表示修复缺陷的重要程度和次序；</li>\n</ul>\n<p>严重级：</p>\n<ul>\n<li>严重：系统崩溃、数据丢失、数据毁坏</li>\n<li>较严重：操作性错误、错误结果、遗漏功能</li>\n<li>一般：小问题、错别字、UI 布局、罕见故障</li>\n<li>建议：不影响使用的瑕疵或更好的实现</li>\n</ul>\n<p>优先级：</p>\n<ul>\n<li>最高优先级：立即修复，停止进一步测试</li>\n<li>次高优先级：在产品发布之前必须修复</li>\n<li>中等优先级：如果时间允许应该修复</li>\n<li>最低等优先级：可能会修复，但是也能发布</li>\n</ul>\n<p>​<br>\n​</p>\n"},{"title":"Test basis.md","url":"/2021/07/18/Test-basis-md/","content":"<h2 id=\"软件测试基本概念\">软件测试基本概念</h2>\n<span id=\"more\"></span>\n<ul>\n<li>\n<p>软件 = 程序+文档，软件测试 = 程序测试+文档测试<br>\n<strong>程序</strong>是指能够实现某种功能的指令集合，<strong>文档</strong>是指软件开发、使用和维护过程中产生的图文集合。</p>\n</li>\n<li>\n<p>软件的分类<br>\n按<strong>功能</strong>分：系统软件，应用软件。<br>\n按<strong>技术架构</strong>分：单机版软件，C/S结构软件（C指客户端，S指服务器端），B/S结构软件（B指浏览器）<br>\n按<strong>用户</strong>划分：产品软件，项目软件。<br>\n按<strong>开发规模</strong>划分：小型，中型，大型。</p>\n</li>\n<li>\n<p>BUG的定义<br>\n软件的BUG指的是软件中（包括程序和文档）<em>不符合用户需求</em>的问题。<br>\n常见的BUG分三种类型：<strong>完全</strong>没有实现功能；<strong>基本实现</strong>了用户需求的功能；实现了用户<strong>不需要的</strong>功能。</p>\n</li>\n<li>\n<p>软件测试的环境 = 软件+网络+硬件+数据准备+测试工具。<br>\n<strong>软件测试的环境要与软件生产运行环境保持一致，要从开发环境独立出来。</strong></p>\n</li>\n<li>\n<p>搭建环境：<strong>真实、干净、无毒、独立。</strong></p>\n</li>\n<li>\n<p>软件环境的分类<br>\n1.软件开发环境:软件在开发过程中使用的环境。<br>\n2.软件生产运行环境:最终用户使用的环境。</p>\n</li>\n<li>\n<p>测试用例：指在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据与其结果。<br>\n<strong>测试用例=输入+输出+测试环境</strong>（输入包括测试数据和操作步骤，输出指的是期望结果，测试环境指的是系统环境设置）。 测试用例有两个模板：word和excel，前者适合性能测试，后者适合功能测试。</p>\n</li>\n</ul>\n<h3 id=\"软件测试分类\">软件测试分类</h3>\n<ul>\n<li>\n<p><strong>黑盒测试</strong>：指的是把被测试的软件看做是一个黑盒子，我们不关心里面的结构是什么样的，只关心软件输入数据和输出结果。<br>\n黑盒测试技术：等价类划分、边界值、因果图、流程图。<br>\n<strong>白盒测试</strong>：指的是把盒子盖打开，去研究里面的源代码和程序结构。</p>\n</li>\n<li>\n<p><strong>静态测试</strong>：是指不实际运行被测软件，而只是静态的检查程序代码、界面或文档中可能存在的错误的过程。<br>\n<strong>动态测试</strong>：是指实际运行被测程序，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程。<br>\n我们判断一个测试属于动态测试还是静态测试的唯一标准就是看是否运行程序。</p>\n</li>\n</ul>\n<blockquote>\n<p><em><strong>注意</strong></em>：同一个测试既有可能属于黑盒测试，也有可能属于动态测试；既有可能属于静态测试，也有可能属于白盒测试。它们之间也有可能交叉。</p>\n<ul>\n<li><strong>按过程分类</strong>\n<ol>\n<li><strong>单元测试</strong>：指的是对软件中最小可测试单元进行检查和验证。</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<pre><code> 2. **集成测试**：是单元测试的下一个阶段，是指将通过测试的单元模块组成系统或子系统，再进行测试，重点测试不同模块的接口部分。\n   \n 3. **系统测试**：指的是将整个软件系统看作1个整体进行测试，包括功能、性能，以及软件所有运行的硬件环境进行测试。\n \n 4. **验收测试**：指的是在系统测试的后期，以用户测试为主，或有测试人员等质量保障人员共同参与的测试它也是软件正式交付给用户使用的最后一道工序。\n 验收测试又分为α测试和β测试，α测试指的是由用户、测试人员、开发人员等共同参与的内部测试；β测试指的是内测后的公测，即完全交给最终的用户测试。\n</code></pre>\n<ul>\n<li>\n<p><strong>功能测试</strong>：是黑盒测试的一方面，它检测实际软件的功能是否符合用户的需求。功能测试又能细分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等。</p>\n</li>\n<li>\n<p><strong>性能测试</strong>：软件的性能包括很多方面，主要有时间性能和空间性能两种。</p>\n<ol>\n<li>时间性能：主要指软件的一个具体事务的响应时间。</li>\n<li>空间性能：主要指软件运行时所消耗的系统资源。</li>\n</ol>\n<p>软件性能测试一般分为一般性能测试、稳定性能测试、负载测试和压力测试。</p>\n<ol>\n<li>\n<p><strong>一般性能测试</strong>：让系统在正常的软硬件环境下运行，不向其施加任何压力的性能测试。</p>\n</li>\n<li>\n<p><strong>稳定性能测试</strong>（又称可靠性测试）：连续运行内测系统，检查系统运行的时间稳定程度。通常用MTBF（错误发生的平均时间间隔）来衡量系统的稳定性，越大稳定性越强。</p>\n</li>\n<li>\n<p><strong>负载测试</strong>：让被测系统在其能忍受的极限范围之内连续运行，来测试系统的稳定性。</p>\n</li>\n<li>\n<p><strong>压力测试</strong>：连续不断的给被测系统增加压力，直到被测系统压垮为止，用来测试系统所能承受的最大压力。<br>\n关于性能测试，可以用一个通俗的例子来理解：</p>\n</li>\n</ol>\n<p>假设一个人很轻松就能背一袋米，背两袋米很吃力，最多就能背三袋米，那么</p>\n<pre><code>  一般性能测试————我就让他背一袋米。\n \n  稳定性测试—————我让他背一袋米，让他去操场上跑圈，看多久累倒。\n \n  负载测试————让他背两袋米去操场去跑圈，看多久累倒。\n \n  压力测试————让他背两袋米，三袋米，四袋米·····发现他最多只能背三袋米。\n</code></pre>\n</li>\n<li>\n<p><strong>回归测试</strong>：是指对软件的新的版本测试时，重复执行上一个版本测试时的用例</p>\n</li>\n<li>\n<p><strong>冒烟测试</strong>：指对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否可以实现，是否具备可测性。</p>\n</li>\n<li>\n<p><strong>随机测试</strong>（又称猴子测试）：指测试中所有的输入数据都是随机生产的，其<strong>目的</strong>是模拟用户的真实操作，并发现边缘错误。<br>\n随机测试的缺点：测试不系统，无法统计代码覆盖率和需求覆盖率，很难回归测试等。</p>\n</li>\n<li>\n<p>不同测试分类之间的关系<br>\n<img src=\"../image/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.png\" alt=\"分类图片\"></p>\n</li>\n<li>\n<p>什么是SQA？<br>\nSQA(Software Quality Assurance,软件质量保障)的完整定义为：为确保软件开发过程和结果符合预期要求而建立的一系列规程，以及依照规程和计划采取的一系列活动及其结果评价。</p>\n</li>\n<li>\n<p>软件测试的一些基本原则</p>\n<ul>\n<li>\n<p>zero bug 和 good enough<br>\nzero bug指的是软件没有任何的bug，good enough指的是只要软件达到一定的质量要求，就可以停止测试了。<br>\ngood enough原则是一种权衡投入/产出比的原则：不充分的测试是不负责任的；过分的测试是一种资源的浪费，同样也是不负责任的表现。</p>\n</li>\n<li>\n<p>不要试图穷举测试<br>\n穷举测试指的是测试时，考虑所有的可能的输入值。这是不切实际的，我们不可能把所有的输入值都考虑到并且这很花费时间和资源。我们需要使用最少的测试用例，来达到最大的覆盖率。</p>\n</li>\n<li>\n<p>软件测试要尽早执行<br>\n在需求分析阶段，引入的缺陷是最多的，修复成本是最少低的。所以要尽早开始软件测试，越到后面，修复成本越高。</p>\n</li>\n<li>\n<p>软件测试应该追溯需求<br>\n软件缺陷产生的原因（如图）<br>\n<img src=\"../image/%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0.png\" alt=\"软件缺陷产生的原因\"></p>\n</li>\n<li>\n<p>缺陷的<strong>二八原则</strong><br>\n二八原则指的是一般情况下，软件80%的缺陷集中在20%的模块中。所以我们测试时，在这20%的模块上，要投入较多的人力和精力重点测试。</p>\n</li>\n<li>\n<p>缺陷具有免疫力<br>\n如同害虫会对农药产生抗药性一样，缺陷也会产生&quot;抗药性&quot;。用旧版本的测试用例去测新版本的软件时，效果会大大的折扣。这就要求我们需要根据新版本的特点去修改和维护测试用。</p>\n<blockquote>\n<p><strong>注意</strong>：每修复三到四个缺陷，一般就会产生一个新的缺陷。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>软件测试模型</p>\n<ul>\n<li>\n<p>瀑布模型</p>\n</li>\n<li>\n<p>V模型<br>\n<img src=\"../image/v%E6%A8%A1%E5%9E%8B.png\" alt=\"v模型\"></p>\n</li>\n<li>\n<p>W模型<br>\n<img src=\"../image/w%E6%A8%A1%E5%9E%8B.png\" alt=\"w模型\"></p>\n</li>\n<li>\n<p>H模型<br>\n<img src=\"../image/h%E6%A8%A1%E5%9E%8B.png\" alt=\"h模型\"></p>\n</li>\n<li>\n<p>x模型<br>\n<img src=\"../image/x%E6%A8%A1%E5%9E%8B.png\" alt=\"x模型\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>黑盒测试技术</p>\n<ul>\n<li>\n<p><strong>等价类划分</strong><br>\n等价类划分可分为有效等价类和无效等价类。</p>\n<blockquote>\n<p>有效等价类：指符合《需求规格说明书》，合理地输入数据集合。<br>\n无效等价类：指不符合《需求规格说明书》，无意义地输入数据集合。</p>\n</blockquote>\n<ul>\n<li>\n<p>等价类栗子：</p>\n<p>假设登录用户名只能是字母和数字，这时字母和数字就是有效等价类，非字母和数字都是无效等价类。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>边界值划分</strong><br>\n边界值指输入和输出等价类中那些恰好处于边界、或者超过边界、或者在边界一下的状态的值。</p>\n<blockquote>\n<p>边界值分析和等价类划分方法存在两方面不同：</p>\n<pre><code>1. 与从等价类中挑选出任意一个元素作为代表不同，边界值分析需要选择一个或多个元素，以便等价类的每个边界都经过一次测试。\n2. 与仅仅关注输入条件（输入空间）不同，还需要考虑从结果空间（输出等价类）设计测试用例。\n</code></pre>\n</blockquote>\n<ul>\n<li>边界值栗子：<br>\n假设输入域输入值范围为1~10，那么0、11就是离点，1、10就是上点，2,9就是内点。</li>\n</ul>\n</li>\n<li>\n<p><strong>决策表</strong><br>\n决策表也被成为判定表，适合描述在不同逻辑条件下取值组合的情况下需要执行的动作。</p>\n<blockquote>\n<p>决策表由四个部分组成：<br>\n决策桩：列出问题中可能出现的条件。<br>\n动作桩：列出解决问题可能采取的操作。<br>\n条件项：针对所有条件的取值列出不同条件取值的组合。<br>\n动作项：在条件项各种取值的情况下应该采取的动作。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>因果图法</strong><br>\n因指的是输入；果指的是输出。因果图法比较适合输入条件比较多的情况。<br>\n因果图有助于用一个系统的方法选择出高效的测试用例集。它还有一个额外的好处，就是可以指出规格说明的不完整性和不明确性。</p>\n<ul>\n<li>因果图栗子：<br>\npass</li>\n</ul>\n</li>\n<li>\n<p><strong>流程图法</strong><br>\n算法流程图是针对程序内部结构的，而黑盒测试的流程图是针对整个系统业务功能流程的。<br>\n流程图法一般不是针对某个页面或是某个模块的测试，而是将被测系统看作一个完整的系统，从宏观上来分析其业务流程，然后再画出流程图。</p>\n<ul>\n<li>流程图栗子：<br>\npass</li>\n</ul>\n</li>\n<li>\n<p><strong>场景法</strong><br>\n根据实际情况，对程序的功能或业务进行描述，模拟特定情况下，可能发生的事件，观察事件的最终结果。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>代码检查、走查与审评（本内容摘抄于《软件测试的艺术》）</p>\n<ul>\n<li>代码检查与走查<br>\n代码检查、走查以及可用性测试是三种主要的人工测试方法。<br>\n所谓<strong>代码检查</strong>，是以组为单位阅读代码，它是一系列规程和错误检查技术的集合。<br>\n<strong>代码走查</strong>与代码检查很相似，但是规程稍微有所不同，采用的错误检查技术也不一样。<br>\n代码检查、走查都要求人们组成一个小组来阅读或直观检查特定的程序。<br>\n代码走查的优点：一旦发现错误，通常就能在代码中对其进行精确定位，降低了调试（错误修正）的成本。这个过程通常发现成批的错误，这样的错误就可以一同得到修正。</li>\n</ul>\n<blockquote>\n<p>代码检查的衍生功效：其一，程序员通常会得到编程风格、算法选择及编程技术等方面的反馈信息。<br>\n其二，其他参与者也可以通过接触程序员的错误和编程风格而同样受益匪浅。<br>\n其三，能够在早期发现程序中脆弱部分的方法之一，有助于在测试过程中将更多的注意力集中在这些脆弱的地方。</p>\n</blockquote>\n<ul>\n<li>用于代码检查的错误列表\n<ol>\n<li>数据引用错误</li>\n<li>数据声明错误</li>\n<li>运算错误</li>\n<li>比较错误</li>\n<li>流程控制错误</li>\n<li>控制流错误</li>\n<li>接口错误</li>\n<li>输入/输出错误</li>\n<li>其他错误</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>白盒测试方法</p>\n<ul>\n<li>\n<p>语句覆盖：<br>\n设计若干个测试用例，使得被测程序的每一条可执行语句至少被执行一次。</p>\n</li>\n<li>\n<p>判定覆盖（分支覆盖）：<br>\n设计若干个测试用例，使得被测程序的每个判定语句至少有一次为真值，有一次为假值。</p>\n</li>\n<li>\n<p>条件覆盖：<br>\n设计若干个测试用例，使得被测程序的每个判定语句中的每个条件的可能结果至少执行一次。</p>\n</li>\n<li>\n<p>判定/条件覆盖：<br>\n设计若干个测试用例，使得被测程序的每个判定语句中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。</p>\n</li>\n<li>\n<p>条件组合覆盖：<br>\n设计若干个测试用例，使得被测程序的每个判定语句中的每个条件的可能结果的所有组合至少执行一次。</p>\n</li>\n<li>\n<p>路径覆盖：<br>\n设计若干个测试用例，使得被测程序中的所有路径执行一次。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"软件失效分类\">软件失效分类</h3>\n<p>软件失效机制可以描述为：软件错误-&gt;软件缺陷-&gt;软件故障-&gt;软件失效</p>\n<ul>\n<li>软件错误是指在软件生存期内的不希望或不可接受的人为错误，其结果是导致软件缺陷的产生。可<br>\n见，软件错误是一种人为过程，相对于软件本身，是一种外部行为。</li>\n<li>软件缺陷存在于软件（文档、数据、程序）之中的那些不希望或不可接受的偏差。其结果是软件运<br>\n行于某一特定条件时出现软件故障，这时称软件缺陷阶段。</li>\n<li>软件故障是指软件运行过程中出现的一种不希望或不可接受的内部状态。</li>\n<li>软件失效是指软件运行时产生的一种不希望或不可接受的外部行为结果。</li>\n</ul>\n<p>错误的定义是：不正确的事务和行为。错误是在系统运行时，引起或可能潜在地引起失效的缺陷，是一种面向开发概念。</p>\n<p>软件缺陷：</p>\n<ul>\n<li>软件未达到产品说明书中标明的功能；</li>\n<li>软件出现了产品说明书中指明的不会出现的错误；</li>\n<li>软件功能超出了产品说明书指明的范围；</li>\n<li>软件未达到产品说明书虽未指出应达到的目标；</li>\n<li>软件测试人员认为软件难以理解、不易使用、运行速度慢，或最终用户认为不好使用。</li>\n</ul>\n<p>产品说明书是软件缺陷的第一来源，也就出自于软件需求说明书本身的问题。</p>\n<p>设计方案（软件设计说明书）是软件缺陷第二来源。</p>\n<h4 id=\"缺陷与错误严重性和优先级\">缺陷与错误严重性和优先级</h4>\n<p>软件缺陷和错误会带来软件失效的风险，重要软件故障与失效会导致重大的经济损失与灾难。给软件缺陷与错误划分严重性和优先级的通用原则是：</p>\n<ul>\n<li>表示软件缺陷所造成的危害的恶劣程度；</li>\n<li>优先级表示修复缺陷的重要程度和次序；</li>\n</ul>\n<p>严重级：</p>\n<ul>\n<li>严重：系统崩溃、数据丢失、数据毁坏</li>\n<li>较严重：操作性错误、错误结果、遗漏功能</li>\n<li>一般：小问题、错别字、UI 布局、罕见故障</li>\n<li>建议：不影响使用的瑕疵或更好的实现</li>\n</ul>\n<p>优先级：</p>\n<ul>\n<li>最高优先级：立即修复，停止进一步测试</li>\n<li>次高优先级：在产品发布之前必须修复</li>\n<li>中等优先级：如果时间允许应该修复</li>\n<li>最低等优先级：可能会修复，但是也能发布</li>\n</ul>\n<p>​<br>\n​</p>\n"}]